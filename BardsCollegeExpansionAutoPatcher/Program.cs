using System.Collections;
using System.Globalization;
using System.Reflection;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

namespace BardsCollegeExpansionAutoPatcher;

public static class Program
{
    private static readonly ModKey BceModKey = ModKey.FromNameAndExtension("kinggathcreations_bard.esm");
    private static readonly FormKey VanillaBardsCollegeCell = new(ModKey.FromNameAndExtension("Skyrim.esm"), 0x016A0C);
    private static readonly FormKey BceBardsCollegeCell = new(BceModKey, 0x01F0F8);
    private static readonly FormKey VanillaWinkingSkeeverCell = new(ModKey.FromNameAndExtension("Skyrim.esm"), 0x016A0E);
    private static readonly FormKey BceWinkingSkeeverCell = new(BceModKey, 0x01F0F7);
    private static readonly FormKey DebugVanillaDoor0006AE55 = new(ModKey.FromNameAndExtension("Skyrim.esm"), 0x06AE55);
    private static readonly FormKey DebugBceDoor0501F42F = new(BceModKey, 0x01F42F);
    private static readonly FormKey DebugBceExteriorDoor020FFE = new(BceModKey, 0x020FFE);
    private static readonly HashSet<ModKey> VanillaMasterModKeys =
    [
        ModKey.FromNameAndExtension("Skyrim.esm"),
        ModKey.FromNameAndExtension("Update.esm"),
        ModKey.FromNameAndExtension("Dawnguard.esm"),
        ModKey.FromNameAndExtension("HearthFires.esm"),
        ModKey.FromNameAndExtension("Dragonborn.esm")
    ];
    private static readonly HashSet<string> SyncedPlacedPropertyNames =
    [
        "Base",
        "Placement",
        "Scale",
        "Emittance",
        "LightData",
        "Radius",
        "EnableParent",
        "MajorFlags",
        "Flags",
        "Ownership",
        "LockData",
        "LinkedReferences",
        "ActivateParents",
        "Primitive",
        "LocationRefType",
        "TeleportDestination"
    ];
    private static readonly HashSet<string> ExcludedCellPropertyNames =
    [
        "FormKey",
        "EditorID",
        "Persistent",
        "Temporary"
    ];

    private static Lazy<Settings> _settings = null!;

    private sealed record ExecutionContext(
        PatchMode Mode,
        ModKey? SourceModKey,
        int? SourceLoadOrderIndex,
        IReadOnlySet<ModKey> BlacklistedMods,
        IReadOnlyDictionary<ModKey, int> LoadOrderIndex)
    {
        public bool IsSourceMode => Mode == PatchMode.SourcePlugin;
    }

    public static async Task<int> Main(string[] args)
    {
        var pipeline = SynthesisPipeline.Instance;
        pipeline.SetAutogeneratedSettings<Settings>("Settings", "settings.json", out _settings);

        return await pipeline
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
            .SetTypicalOpen(GameRelease.SkyrimSE, "BardsCollegeExpansionPatch.esp")
            .Run(args);
    }

    public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        var settings = _settings.Value;
        var blacklistedMods = ParseBlacklist(settings.BlacklistedPlugins);
        var loadOrderIndex = state.LoadOrder.ListedOrder
            .Select((listing, index) => (listing.ModKey, index))
            .ToDictionary(x => x.ModKey, x => x.index);

        var bceModPresent = state.LoadOrder.ContainsKey(BceModKey);
        if (!bceModPresent)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Required mod missing: {BceModKey.FileName}");
            return;
        }

        if (!state.PatchMod.ModHeader.MasterReferences.Any(master => master.Master == BceModKey))
        {
            state.PatchMod.ModHeader.MasterReferences.Add(new MasterReference { Master = BceModKey });
        }

        var bardsCsvPath = Path.Combine(AppContext.BaseDirectory, "BardsCollegeMatchingRefs.csv");
        if (!File.Exists(bardsCsvPath))
        {
            throw new FileNotFoundException($"Could not locate bundled CSV file at '{bardsCsvPath}'.", bardsCsvPath);
        }

        var winkingCsvPath = Path.Combine(AppContext.BaseDirectory, "WinkingSkeeverMatchingRefs.csv");
        if (!File.Exists(winkingCsvPath))
        {
            throw new FileNotFoundException($"Could not locate bundled CSV file at '{winkingCsvPath}'.", winkingCsvPath);
        }

        var bardsRefMapping = RefMapping.Load(bardsCsvPath);
        var winkingRefMapping = RefMapping.Load(winkingCsvPath);

        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] BCE detected: {BceModKey.FileName}");
        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Loaded {bardsRefMapping.Cell1ToCell2.Count} Bards College reference mappings.");
        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Loaded {winkingRefMapping.Cell1ToCell2.Count} Winking Skeever reference mappings.");

        if (settings.Debug)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Bards vanilla cell: {VanillaBardsCollegeCell}");
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Bards BCE cell: {BceBardsCollegeCell}");
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Winking Skeever vanilla cell: {VanillaWinkingSkeeverCell}");
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Winking Skeever BCE cell: {BceWinkingSkeeverCell}");
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Blacklist size: {settings.BlacklistedPlugins.Count}");
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Bards Cell1 CSV prefixes: {string.Join(", ", bardsRefMapping.Cell1LoadOrderPrefixes)}");
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Bards Cell2 CSV prefixes: {string.Join(", ", bardsRefMapping.Cell2LoadOrderPrefixes)}");
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Winking Skeever Cell1 CSV prefixes: {string.Join(", ", winkingRefMapping.Cell1LoadOrderPrefixes)}");
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Winking Skeever Cell2 CSV prefixes: {string.Join(", ", winkingRefMapping.Cell2LoadOrderPrefixes)}");
        }

        if (bardsRefMapping.Cell1LoadOrderPrefixes.Any(prefix => !string.Equals(prefix, "00", StringComparison.Ordinal)))
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Warning: Bards Cell1 mapping contains non-00 load-order prefixes.");
        }

        if (winkingRefMapping.Cell1LoadOrderPrefixes.Any(prefix => !string.Equals(prefix, "00", StringComparison.Ordinal)))
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Warning: Winking Skeever Cell1 mapping contains non-00 load-order prefixes.");
        }

        if (!TryBuildExecutionContext(state, settings, blacklistedMods, loadOrderIndex, out var executionContext))
        {
            return;
        }

        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Active patch mode: {executionContext.Mode}");
        if (executionContext.IsSourceMode)
        {
            Console.WriteLine(
                $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Source plugin: {executionContext.SourceModKey!.Value.FileName} (load order index {executionContext.SourceLoadOrderIndex}).");
        }
        else
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Global mode: SourcePlugin setting is ignored.");
        }

        if (executionContext.IsSourceMode)
        {
            RunSourcePluginMode(state, settings, executionContext, bardsRefMapping, winkingRefMapping);
        }
        else
        {
            RunGlobalMode(state, settings, executionContext, bardsRefMapping, winkingRefMapping);
        }
    }

    private static bool TryBuildExecutionContext(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        HashSet<ModKey> blacklistedMods,
        Dictionary<ModKey, int> loadOrderIndex,
        out ExecutionContext executionContext)
    {
        if (settings.Mode == PatchMode.Global)
        {
            executionContext = new ExecutionContext(
                Mode: PatchMode.Global,
                SourceModKey: null,
                SourceLoadOrderIndex: null,
                BlacklistedMods: blacklistedMods,
                LoadOrderIndex: loadOrderIndex);
            return true;
        }

        var sourceModKey = settings.SourcePlugin;
        if (sourceModKey.IsNull)
        {
            Console.WriteLine(
                $"[{nameof(BardsCollegeExpansionAutoPatcher)}] SourcePlugin is required when Mode={PatchMode.SourcePlugin}.");
            executionContext = null!;
            return false;
        }

        if (!state.LoadOrder.ContainsKey(sourceModKey))
        {
            Console.WriteLine(
                $"[{nameof(BardsCollegeExpansionAutoPatcher)}] SourcePlugin is not present in load order: {sourceModKey.FileName}.");
            executionContext = null!;
            return false;
        }

        if (blacklistedMods.Contains(sourceModKey))
        {
            Console.WriteLine(
                $"[{nameof(BardsCollegeExpansionAutoPatcher)}] SourcePlugin cannot be blacklisted: {sourceModKey.FileName}.");
            executionContext = null!;
            return false;
        }

        if (sourceModKey == BceModKey)
        {
            Console.WriteLine(
                $"[{nameof(BardsCollegeExpansionAutoPatcher)}] SourcePlugin cannot be BCE itself: {sourceModKey.FileName}.");
            executionContext = null!;
            return false;
        }

        if (VanillaMasterModKeys.Contains(sourceModKey))
        {
            Console.WriteLine(
                $"[{nameof(BardsCollegeExpansionAutoPatcher)}] SourcePlugin cannot be a vanilla master: {sourceModKey.FileName}.");
            executionContext = null!;
            return false;
        }

        if (sourceModKey == state.PatchMod.ModKey)
        {
            Console.WriteLine(
                $"[{nameof(BardsCollegeExpansionAutoPatcher)}] SourcePlugin cannot match output patch plugin: {sourceModKey.FileName}.");
            executionContext = null!;
            return false;
        }

        if (!loadOrderIndex.TryGetValue(sourceModKey, out var sourceLoadOrderIndex))
        {
            Console.WriteLine(
                $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Could not determine load-order index for source plugin: {sourceModKey.FileName}.");
            executionContext = null!;
            return false;
        }

        executionContext = new ExecutionContext(
            Mode: PatchMode.SourcePlugin,
            SourceModKey: sourceModKey,
            SourceLoadOrderIndex: sourceLoadOrderIndex,
            BlacklistedMods: blacklistedMods,
            LoadOrderIndex: loadOrderIndex);
        return true;
    }

    private static void RunSourcePluginMode(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        ExecutionContext executionContext,
        RefMapping bardsRefMapping,
        RefMapping winkingRefMapping)
    {
        var intentionallyModifiedFormKeys = new HashSet<FormKey>();
        var movedBardsReferences = new HashSet<FormKey>();
        var copiedWinkingReferences = new HashSet<FormKey>();

        MoveNewReferencesToBceCell(state, settings, executionContext, bardsRefMapping, intentionallyModifiedFormKeys, movedBardsReferences);
        SyncMappedReferencesToBce(state, settings, executionContext, bardsRefMapping, intentionallyModifiedFormKeys);
        CopyNewReferencesToBceWinkingCell(state, settings, executionContext, winkingRefMapping, intentionallyModifiedFormKeys, copiedWinkingReferences);
        SyncWinkingMappedReferencesToBce(state, settings, executionContext, winkingRefMapping, intentionallyModifiedFormKeys);
        SwapCellAndReferencePointers(
            state,
            settings,
            executionContext,
            bardsRefMapping,
            intentionallyModifiedFormKeys,
            movedBardsReferences,
            copiedWinkingReferences);
        RewireMovedReplacementDoorsForBardsCollege(state, settings, intentionallyModifiedFormKeys, bardsRefMapping, movedBardsReferences);
        RemapBardsCollegeNavigationDoorLinks(state, settings, intentionallyModifiedFormKeys, movedBardsReferences);

        CleanupUnintentionalPatchRecords(state, intentionallyModifiedFormKeys, settings);
        SyncPatchHeaderRecordCount(state, settings);
    }

    private static void RunGlobalMode(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        ExecutionContext executionContext,
        RefMapping bardsRefMapping,
        RefMapping winkingRefMapping)
    {
        var intentionallyModifiedFormKeys = new HashSet<FormKey>();
        var movedBardsReferences = new HashSet<FormKey>();
        var copiedWinkingReferences = new HashSet<FormKey>();

        MoveNewReferencesToBceCell(state, settings, executionContext, bardsRefMapping, intentionallyModifiedFormKeys, movedBardsReferences);
        SyncMappedReferencesToBce(state, settings, executionContext, bardsRefMapping, intentionallyModifiedFormKeys);
        CopyNewReferencesToBceWinkingCell(state, settings, executionContext, winkingRefMapping, intentionallyModifiedFormKeys, copiedWinkingReferences);
        SyncWinkingMappedReferencesToBce(state, settings, executionContext, winkingRefMapping, intentionallyModifiedFormKeys);
        SwapCellAndReferencePointers(
            state,
            settings,
            executionContext,
            bardsRefMapping,
            intentionallyModifiedFormKeys,
            movedBardsReferences,
            copiedWinkingReferences);
        RewireMovedReplacementDoorsForBardsCollege(state, settings, intentionallyModifiedFormKeys, bardsRefMapping, movedBardsReferences);
        RemapBardsCollegeNavigationDoorLinks(state, settings, intentionallyModifiedFormKeys, movedBardsReferences);

        CleanupUnintentionalPatchRecords(state, intentionallyModifiedFormKeys, settings);
        SyncPatchHeaderRecordCount(state, settings);
    }

    private static void MoveNewReferencesToBceCell(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        ExecutionContext executionContext,
        RefMapping refMapping,
        HashSet<FormKey> intentionallyModifiedFormKeys,
        HashSet<FormKey> movedBardsReferences)
    {
        TransferNewReferencesToBceCell(
            state,
            settings,
            executionContext,
            refMapping,
            intentionallyModifiedFormKeys,
            trackedTransferredReferences: movedBardsReferences,
            VanillaBardsCollegeCell,
            BceBardsCollegeCell,
            removeFromVanillaCell: true,
            locationName: "Bards College");
    }

    private static void CopyNewReferencesToBceWinkingCell(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        ExecutionContext executionContext,
        RefMapping refMapping,
        HashSet<FormKey> intentionallyModifiedFormKeys,
        HashSet<FormKey> copiedWinkingReferences)
    {
        TransferNewReferencesToBceCell(
            state,
            settings,
            executionContext,
            refMapping,
            intentionallyModifiedFormKeys,
            trackedTransferredReferences: copiedWinkingReferences,
            VanillaWinkingSkeeverCell,
            BceWinkingSkeeverCell,
            removeFromVanillaCell: false,
            locationName: "Winking Skeever");
    }

    private static void TransferNewReferencesToBceCell(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        ExecutionContext executionContext,
        RefMapping refMapping,
        HashSet<FormKey> intentionallyModifiedFormKeys,
        HashSet<FormKey>? trackedTransferredReferences,
        FormKey vanillaCell,
        FormKey bceCell,
        bool removeFromVanillaCell,
        string locationName)
    {
        var winningCells = state.LoadOrder.PriorityOrder
            .Cell()
            .WinningContextOverrides(state.LinkCache)
            .ToDictionary(x => x.Record.FormKey, x => x);

        if (!winningCells.TryGetValue(vanillaCell, out var vanillaCellContext))
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Could not resolve vanilla cell {vanillaCell} for {locationName}.");
            return;
        }

        if (!winningCells.TryGetValue(bceCell, out var bceCellContext))
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Could not resolve BCE cell {bceCell} for {locationName}.");
            return;
        }

        var vanillaCellGetter = vanillaCellContext.Record;
        IEnumerable<IPlacedGetter> candidateInputs;
        HashSet<FormKey> activePersistentRefs;
        HashSet<FormKey> activeTemporaryRefs;

        if (executionContext.IsSourceMode)
        {
            if (!TryGetSourceAndPreviousRecords<ICellGetter>(state, vanillaCell, executionContext, out var sourceCell, out var previousCell))
            {
                Console.WriteLine(
                    $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 2 ({locationName}): source plugin does not provide usable cell delta.");
                return;
            }

            var sourceRefsByFormKey = EnumerateCellPlaced(sourceCell)
                .GroupBy(x => x.FormKey)
                .ToDictionary(x => x.Key, x => x.First());
            var previousRefKeys = EnumerateCellPlaced(previousCell)
                .Select(x => x.FormKey)
                .ToHashSet();
            var addedFormKeys = sourceRefsByFormKey.Keys
                .Where(formKey => !previousRefKeys.Contains(formKey))
                .ToList();

            candidateInputs = addedFormKeys
                .Select(formKey => sourceRefsByFormKey[formKey]);
            activePersistentRefs = sourceCell.Persistent?.Select(x => x.FormKey).ToHashSet() ?? [];
            activeTemporaryRefs = sourceCell.Temporary?.Select(x => x.FormKey).ToHashSet() ?? [];

            if (settings.Debug)
            {
                Console.WriteLine(
                    $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 2 ({locationName}): source cell added refs={addedFormKeys.Count} (previous->source delta).");
            }
        }
        else
        {
            candidateInputs = EnumerateCellPlaced(vanillaCellGetter)
                .GroupBy(x => x.FormKey)
                .Select(x => x.First());
            activePersistentRefs = vanillaCellGetter.Persistent?.Select(x => x.FormKey).ToHashSet() ?? [];
            activeTemporaryRefs = vanillaCellGetter.Temporary?.Select(x => x.FormKey).ToHashSet() ?? [];
        }

        var candidates = new List<IPlacedGetter>();
        foreach (var placed in candidateInputs)
        {
            if (placed is not IPlacedObjectGetter && placed is not IPlacedNpcGetter && placed is not IAPlacedTrapGetter)
            {
                continue;
            }

            if (IsRoomMarkerPlacedReference(state, placed))
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 2: skipped {placed.FormKey} (room marker).");
                }

                continue;
            }

            var sourceMod = placed.FormKey.ModKey;
            if (!executionContext.IsSourceMode && VanillaMasterModKeys.Contains(sourceMod))
            {
                continue;
            }

            if (sourceMod == BceModKey)
            {
                continue;
            }

            if (!executionContext.IsSourceMode && executionContext.BlacklistedMods.Contains(sourceMod))
            {
                continue;
            }

            if (refMapping.AllCell1Refs.Contains(placed.FormKey))
            {
                continue;
            }

            if (!IsTrulyNewReference(state, placed.FormKey))
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 2: skipped {placed.FormKey} (override of existing reference, not a net-new placed ref).");
                }

                continue;
            }

            candidates.Add(placed);
        }

        if (candidates.Count == 0)
        {
            var action = removeFromVanillaCell ? "move" : "copy";
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 2 ({locationName}): no new references to {action}.");
            return;
        }

        var vanillaCellOverride = vanillaCellContext.GetOrAddAsOverride(state.PatchMod);
        var bceCellOverride = bceCellContext.GetOrAddAsOverride(state.PatchMod);

        var movedCount = 0;
        foreach (var placed in candidates)
        {
            var shouldBePersistent = activePersistentRefs.Contains(placed.FormKey) || !activeTemporaryRefs.Contains(placed.FormKey);
            var copied = ClonePlaced(placed);

            if (removeFromVanillaCell)
            {
                RemovePlacedByFormKey(vanillaCellOverride.Persistent, placed.FormKey);
                RemovePlacedByFormKey(vanillaCellOverride.Temporary, placed.FormKey);
            }

            RemovePlacedByFormKey(bceCellOverride.Persistent, placed.FormKey);
            RemovePlacedByFormKey(bceCellOverride.Temporary, placed.FormKey);

            if (shouldBePersistent)
            {
                bceCellOverride.Persistent.Add(copied);
            }
            else
            {
                bceCellOverride.Temporary.Add(copied);
            }

            movedCount++;
            intentionallyModifiedFormKeys.Add(placed.FormKey);
            trackedTransferredReferences?.Add(placed.FormKey);

            if (settings.Debug)
            {
                var destination = shouldBePersistent ? "Persistent" : "Temporary";
                var action = removeFromVanillaCell ? "Moved" : "Copied";
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] {action} {placed.FormKey} -> {locationName} BCE {destination}.");
            }
        }

        intentionallyModifiedFormKeys.Add(vanillaCellOverride.FormKey);
        intentionallyModifiedFormKeys.Add(bceCellOverride.FormKey);
        var verb = removeFromVanillaCell ? "moved" : "copied";
        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 2 ({locationName}): {verb} {movedCount} references to BCE cell.");
    }

    private static bool IsRoomMarkerPlacedReference(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        IPlacedGetter placed)
    {
        if (placed is not IPlacedObjectGetter placedObject)
        {
            return false;
        }

        var baseFormKey = placedObject.Base.FormKey;
        if (baseFormKey.IsNull)
        {
            return false;
        }

        if (!state.LinkCache.TryResolve<IMajorRecordGetter>(baseFormKey, out var baseRecord))
        {
            return false;
        }

        var editorIdProperty = baseRecord.GetType().GetProperty("EditorID", BindingFlags.Public | BindingFlags.Instance);
        if (editorIdProperty is null || !editorIdProperty.CanRead)
        {
            return false;
        }

        var editorId = editorIdProperty.GetValue(baseRecord) as string;
        if (string.IsNullOrWhiteSpace(editorId))
        {
            return false;
        }

        return editorId.Contains("RoomMarker", StringComparison.OrdinalIgnoreCase);
    }

    private static IPlaced ClonePlaced(IPlacedGetter placed)
    {
        return placed switch
        {
            IPlacedObjectGetter placedObject => placedObject.DeepCopy(),
            IPlacedNpcGetter placedNpc => placedNpc.DeepCopy(),
            IAPlacedTrapGetter placedTrap => placedTrap.DeepCopy(),
            _ => throw new InvalidOperationException($"Unsupported placed record type: {placed.GetType().Name}")
        };
    }

    private static HashSet<ModKey> ParseBlacklist(IEnumerable<ModKey> rawBlacklist)
    {
        return rawBlacklist
            .Where(modKey => !modKey.IsNull)
            .ToHashSet();
    }

    private static IEnumerable<IPlacedGetter> EnumerateCellPlaced(ICellGetter cell)
    {
        return (cell.Persistent ?? []).Concat(cell.Temporary ?? []);
    }

    private static bool TryGetSourceAndPreviousRecords<TRecordGetter>(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        FormKey formKey,
        ExecutionContext executionContext,
        out TRecordGetter sourceRecord,
        out TRecordGetter previousRecord)
        where TRecordGetter : class, IMajorRecordGetter
    {
        sourceRecord = null!;
        previousRecord = null!;

        if (!executionContext.IsSourceMode
            || executionContext.SourceModKey is null
            || executionContext.SourceLoadOrderIndex is null)
        {
            return false;
        }

        var sourceModKey = executionContext.SourceModKey.Value;
        var sourceLoadOrderIndex = executionContext.SourceLoadOrderIndex.Value;

        var orderedContexts = formKey
            .ToLink<TRecordGetter>()
            .ResolveAllSimpleContexts<TRecordGetter>(state.LinkCache)
            .Where(context => context.ModKey != state.PatchMod.ModKey && !executionContext.BlacklistedMods.Contains(context.ModKey))
            .Select(context =>
            {
                var index = executionContext.LoadOrderIndex.TryGetValue(context.ModKey, out var resolvedIndex)
                    ? resolvedIndex
                    : int.MinValue;
                return (Context: context, Index: index);
            })
            .OrderBy(x => x.Index)
            .ToList();

        var sourceContext = orderedContexts.FirstOrDefault(x => x.Context.ModKey == sourceModKey).Context;
        if (sourceContext is null)
        {
            return false;
        }

        var previousContext = orderedContexts
            .Where(x => x.Index < sourceLoadOrderIndex)
            .Select(x => x.Context)
            .LastOrDefault();
        if (previousContext is null)
        {
            return false;
        }

        sourceRecord = sourceContext.Record;
        previousRecord = previousContext.Record;
        return true;
    }

    private static bool RemovePlacedByFormKey(IList<IPlaced> list, FormKey formKey)
    {
        var removed = false;
        for (var i = list.Count - 1; i >= 0; i--)
        {
            if (list[i].FormKey != formKey)
            {
                continue;
            }

            list.RemoveAt(i);
            removed = true;
        }

        return removed;
    }

    private static bool IsTrulyNewReference(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        FormKey formKey)
    {
        var contexts = formKey
            .ToLink<IPlacedGetter>()
            .ResolveAllSimpleContexts<IPlacedGetter>(state.LinkCache)
            .Where(x => x.ModKey != state.PatchMod.ModKey)
            .ToList();

        if (contexts.Count == 0)
        {
            return true;
        }

        // If any vanilla context exists in the history, this is an override chain on an existing record.
        return !contexts.Any(x => VanillaMasterModKeys.Contains(x.ModKey));
    }

    private static void SyncMappedReferencesToBce(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        ExecutionContext executionContext,
        RefMapping refMapping,
        HashSet<FormKey> intentionallyModifiedFormKeys)
    {
        SyncMappedReferencesToBceForCell(
            state,
            settings,
            executionContext,
            refMapping,
            intentionallyModifiedFormKeys,
            VanillaBardsCollegeCell,
            BceBardsCollegeCell,
            locationName: "Bards College");
    }

    private static void SyncWinkingMappedReferencesToBce(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        ExecutionContext executionContext,
        RefMapping refMapping,
        HashSet<FormKey> intentionallyModifiedFormKeys)
    {
        SyncMappedReferencesToBceForCell(
            state,
            settings,
            executionContext,
            refMapping,
            intentionallyModifiedFormKeys,
            VanillaWinkingSkeeverCell,
            BceWinkingSkeeverCell,
            locationName: "Winking Skeever");
    }

    private static void SyncMappedReferencesToBceForCell(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        ExecutionContext executionContext,
        RefMapping refMapping,
        HashSet<FormKey> intentionallyModifiedFormKeys,
        FormKey vanillaCell,
        FormKey bceCell,
        string locationName)
    {
        var evaluated = 0;
        var changed = 0;

        foreach (var pair in refMapping.Cell1ToCell2)
        {
            evaluated++;

            IPlacedGetter sourceRecord;
            IPlacedGetter comparisonBaselineRecord;
            ModKey deltaSourceModKey;

            if (executionContext.IsSourceMode)
            {
                if (!TryGetSourceAndPreviousRecords<IPlacedGetter>(
                        state,
                        pair.Key,
                        executionContext,
                        out sourceRecord,
                        out comparisonBaselineRecord))
                {
                    continue;
                }

                deltaSourceModKey = executionContext.SourceModKey!.Value;
            }
            else
            {
                var cell1Link = pair.Key.ToLink<IPlacedGetter>();
                var allCell1Contexts = cell1Link
                    .ResolveAllSimpleContexts<IPlacedGetter>(state.LinkCache)
                    .Select(x => (Typed: x, Untyped: (IModContext)x))
                    .Where(x => x.Untyped.ModKey != state.PatchMod.ModKey)
                    .ToList();
                if (allCell1Contexts.Count == 0)
                {
                    continue;
                }

                var sourceContext = allCell1Contexts.FirstOrDefault(x => x.Untyped.ModKey == pair.Key.ModKey);
                if (sourceContext.Typed is null)
                {
                    continue;
                }

                var winningContext = allCell1Contexts
                    .Where(x => !executionContext.BlacklistedMods.Contains(x.Untyped.ModKey))
                    .OrderBy(x => executionContext.LoadOrderIndex.TryGetValue(x.Untyped.ModKey, out var index) ? index : int.MinValue)
                    .LastOrDefault();
                if (winningContext.Typed is null)
                {
                    continue;
                }

                var winningModKey = winningContext.Untyped.ModKey;
                if (VanillaMasterModKeys.Contains(winningModKey) || winningModKey == BceModKey || executionContext.BlacklistedMods.Contains(winningModKey))
                {
                    continue;
                }

                sourceRecord = winningContext.Typed.Record;
                comparisonBaselineRecord = sourceContext.Typed.Record;
                deltaSourceModKey = winningModKey;
            }

            var cell2Link = pair.Value.ToLink<IPlacedGetter>();
            if (!cell2Link.TryResolveContext<ISkyrimMod, ISkyrimModGetter, IPlaced, IPlacedGetter>(state.LinkCache, out var cell2Context))
            {
                continue;
            }

            var cell2Override = cell2Context.GetOrAddAsOverride(state.PatchMod);
            if (!HaveMatchingPlacedKind(sourceRecord, cell2Override))
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: type mismatch for {pair.Key} -> {pair.Value}, skipping.");
                }

                continue;
            }

            if (!ApplyChangedProperties(comparisonBaselineRecord, sourceRecord, cell2Override, settings))
            {
                continue;
            }

            changed++;
            intentionallyModifiedFormKeys.Add(cell2Override.FormKey);

            if (settings.Debug)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: synced {pair.Key} -> {pair.Value} from {deltaSourceModKey.FileName}.");
            }
        }

        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 ({locationName}): evaluated {evaluated} mapped refs, synced {changed}.");

        SyncCellChanges(state, settings, executionContext, intentionallyModifiedFormKeys, vanillaCell, bceCell, locationName);
    }

    private static void SyncBardsCollegeCellChanges(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        ExecutionContext executionContext,
        HashSet<FormKey> intentionallyModifiedFormKeys)
    {
        SyncCellChanges(state, settings, executionContext, intentionallyModifiedFormKeys, VanillaBardsCollegeCell, BceBardsCollegeCell, "Bards College");
    }

    private static void SyncCellChanges(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        ExecutionContext executionContext,
        HashSet<FormKey> intentionallyModifiedFormKeys,
        FormKey vanillaCell,
        FormKey bceCell,
        string locationName)
    {
        ICellGetter sourceRecord;
        ICellGetter baselineRecord;
        ModKey deltaSourceModKey;

        if (executionContext.IsSourceMode)
        {
            if (!TryGetSourceAndPreviousRecords<ICellGetter>(state, vanillaCell, executionContext, out sourceRecord, out baselineRecord))
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync ({locationName}): source plugin does not override {vanillaCell}.");
                return;
            }

            deltaSourceModKey = executionContext.SourceModKey!.Value;
        }
        else
        {
            var vanillaCellLink = vanillaCell.ToLink<ICellGetter>();
            var allVanillaCellContexts = vanillaCellLink
                .ResolveAllSimpleContexts<ICellGetter>(state.LinkCache)
                .Select(x => (Typed: x, Untyped: (IModContext)x))
                .Where(x => x.Untyped.ModKey != state.PatchMod.ModKey)
                .ToList();
            if (allVanillaCellContexts.Count == 0)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync ({locationName}): no contexts found for {vanillaCell}.");
                return;
            }

            var sourceContext = allVanillaCellContexts.FirstOrDefault(x => x.Untyped.ModKey == vanillaCell.ModKey);
            if (sourceContext.Typed is null)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync ({locationName}): source context missing for {vanillaCell}.");
                return;
            }

            var winningContext = allVanillaCellContexts
                .Where(x => !executionContext.BlacklistedMods.Contains(x.Untyped.ModKey))
                .OrderBy(x => executionContext.LoadOrderIndex.TryGetValue(x.Untyped.ModKey, out var index) ? index : int.MinValue)
                .LastOrDefault();
            if (winningContext.Typed is null)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync ({locationName}): winning context missing for {vanillaCell}.");
                return;
            }

            var winningModKey = winningContext.Untyped.ModKey;
            if (VanillaMasterModKeys.Contains(winningModKey) || winningModKey == BceModKey || executionContext.BlacklistedMods.Contains(winningModKey))
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync ({locationName}): skipped (winning mod {winningModKey.FileName} is excluded).");
                }

                return;
            }

            sourceRecord = winningContext.Typed.Record;
            baselineRecord = sourceContext.Typed.Record;
            deltaSourceModKey = winningModKey;
        }

        var bceCellLink = bceCell.ToLink<ICellGetter>();
        if (!bceCellLink.TryResolveContext<ISkyrimMod, ISkyrimModGetter, ICell, ICellGetter>(state.LinkCache, out var bceCellContext))
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync ({locationName}): could not resolve BCE cell {bceCell}.");
            return;
        }

        var bceCellOverride = bceCellContext.GetOrAddAsOverride(state.PatchMod);
        var changedAny = ApplyChangedCellProperties(baselineRecord, sourceRecord, bceCellOverride, settings);
        if (!changedAny)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync ({locationName}): no cell-level changes to mirror.");
            return;
        }

        intentionallyModifiedFormKeys.Add(bceCellOverride.FormKey);
        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync ({locationName}): mirrored cell-level changes from {deltaSourceModKey.FileName} to BCE cell.");
    }

    private static bool ApplyChangedCellProperties(
        object originalRecord,
        object winningRecord,
        object targetRecord,
        Settings settings)
    {
        var changedAny = false;
        var targetType = targetRecord.GetType();
        var originalType = originalRecord.GetType();
        var winningType = winningRecord.GetType();

        foreach (var targetProperty in targetType.GetProperties())
        {
            if (!targetProperty.CanRead || !targetProperty.CanWrite)
            {
                continue;
            }

            if (targetProperty.GetIndexParameters().Length > 0)
            {
                continue;
            }

            if (ExcludedCellPropertyNames.Contains(targetProperty.Name))
            {
                continue;
            }

            var originalProperty = originalType.GetProperty(targetProperty.Name);
            var winningProperty = winningType.GetProperty(targetProperty.Name);
            if (originalProperty is null || winningProperty is null || !originalProperty.CanRead || !winningProperty.CanRead)
            {
                continue;
            }

            var originalValue = originalProperty.GetValue(originalRecord);
            var winningValue = winningProperty.GetValue(winningRecord);
            if (ValuesEqual(originalValue, winningValue))
            {
                continue;
            }

            if (TryAssignCompositeProperty(targetRecord, targetProperty, winningValue, settings))
            {
                changedAny = true;
                continue;
            }

            if (settings.Debug)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync: skipped '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)}.");
            }
        }

        return changedAny;
    }

    private static void SwapCellAndReferencePointers(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        ExecutionContext executionContext,
        RefMapping refMapping,
        HashSet<FormKey> intentionallyModifiedFormKeys,
        HashSet<FormKey> movedBardsReferences,
        HashSet<FormKey> copiedWinkingReferences)
    {
        var swapMap = BuildSwapMap(refMapping);
        var bceBardsCellOverride = GetBceCellOverrideOrNull(state, BceBardsCollegeCell);
        var bceWinkingCellOverride = GetBceCellOverrideOrNull(state, BceWinkingSkeeverCell);

        var evaluatedRecords = 0;
        var qualifyingRecords = 0;
        var swappedRecords = 0;
        var swappedLinks = 0;

        if (executionContext.IsSourceMode)
        {
            var sourceModKey = executionContext.SourceModKey!.Value;
            foreach (var winningContext in state.LoadOrder.ListedOrder.WinningContextOverrides<ISkyrimMod, ISkyrimModGetter, IMajorRecord, IMajorRecordGetter>(state.LinkCache))
            {
                if (winningContext.ModKey == state.PatchMod.ModKey || executionContext.BlacklistedMods.Contains(winningContext.ModKey))
                {
                    continue;
                }

                var sourceContext = winningContext.Record.FormKey
                    .ToLink<IMajorRecordGetter>()
                    .ResolveAllSimpleContexts<IMajorRecordGetter>(state.LinkCache)
                    .FirstOrDefault(x => x.ModKey == sourceModKey);
                if (sourceContext is null)
                {
                    continue;
                }

                evaluatedRecords++;
                if (sourceContext.Record is not IFormLinkContainerGetter sourceRecordWithLinks)
                {
                    continue;
                }

                var matchedLinksInRecord = sourceRecordWithLinks
                    .EnumerateFormLinks()
                    .Count(link => swapMap.ContainsKey(link.FormKey));
                if (matchedLinksInRecord == 0)
                {
                    continue;
                }

                qualifyingRecords++;
                var overrideRecord = winningContext.GetOrAddAsOverride(state.PatchMod);
                if (overrideRecord is not IFormLinkContainer mutableRecord)
                {
                    if (settings.Debug)
                    {
                        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 4: skipped {winningContext.Record.FormKey} (not mutable FormLink container).");
                    }

                    continue;
                }

                mutableRecord.RemapLinks(swapMap);
                swappedRecords++;
                swappedLinks += matchedLinksInRecord;
                intentionallyModifiedFormKeys.Add(overrideRecord.FormKey);

                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 4: remapped {matchedLinksInRecord} links in {overrideRecord.FormKey} from {sourceModKey.FileName}.");
                }
            }
        }
        else
        {
        foreach (var context in state.LoadOrder.ListedOrder.WinningContextOverrides<ISkyrimMod, ISkyrimModGetter, IMajorRecord, IMajorRecordGetter>(state.LinkCache))
        {
            evaluatedRecords++;
            var sourceModKey = context.ModKey;
            if (sourceModKey == state.PatchMod.ModKey
                || sourceModKey == BceModKey
                || VanillaMasterModKeys.Contains(sourceModKey)
                || executionContext.BlacklistedMods.Contains(sourceModKey))
            {
                continue;
            }

            if (context.Record is not IFormLinkContainerGetter recordWithLinks)
            {
                continue;
            }

            var matchedLinksInRecord = recordWithLinks
                .EnumerateFormLinks()
                .Count(link => swapMap.ContainsKey(link.FormKey));
            if (matchedLinksInRecord == 0)
            {
                continue;
            }

            qualifyingRecords++;

            if (bceBardsCellOverride is not null
                && TryGetPatchedPlacedByFormKey(bceBardsCellOverride, context.Record.FormKey, out var patchedPlaced)
                && patchedPlaced is IFormLinkContainer patchedPlacedWithLinks)
            {
                patchedPlacedWithLinks.RemapLinks(swapMap);
                swappedRecords++;
                swappedLinks += matchedLinksInRecord;
                intentionallyModifiedFormKeys.Add(bceBardsCellOverride.FormKey);
                intentionallyModifiedFormKeys.Add(patchedPlaced.FormKey);

                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 4: merged remap into BCE cell record {patchedPlaced.FormKey}.");
                }

                continue;
            }

            var overrideRecord = context.GetOrAddAsOverride(state.PatchMod);
            if (overrideRecord is not IFormLinkContainer mutableRecord)
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 4: skipped {context.Record.FormKey} (not mutable FormLink container).");
                }

                continue;
            }

            mutableRecord.RemapLinks(swapMap);
            swappedRecords++;
            swappedLinks += matchedLinksInRecord;
            intentionallyModifiedFormKeys.Add(overrideRecord.FormKey);

            if (settings.Debug)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 4: remapped {matchedLinksInRecord} links in {overrideRecord.FormKey} from {sourceModKey.FileName}.");
            }
        }
        }

        swappedLinks += RemapLinksInTransferredPlacedRecords(
            bceBardsCellOverride,
            movedBardsReferences,
            swapMap,
            intentionallyModifiedFormKeys,
            out var transferredBardsSwappedRecords);
        swappedLinks += RemapLinksInTransferredPlacedRecords(
            bceWinkingCellOverride,
            copiedWinkingReferences,
            swapMap,
            intentionallyModifiedFormKeys,
            out var transferredWinkingSwappedRecords);
        swappedRecords += transferredBardsSwappedRecords + transferredWinkingSwappedRecords;

        Console.WriteLine(
            $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 4: evaluated {evaluatedRecords} records, "
            + $"found {qualifyingRecords} with BCE swaps, remapped {swappedLinks} links across {swappedRecords} records.");
    }

    private static Dictionary<FormKey, FormKey> BuildSwapMap(RefMapping refMapping)
    {
        var map = new Dictionary<FormKey, FormKey>(refMapping.Cell1ToCell2.Count + 1)
        {
            [VanillaBardsCollegeCell] = BceBardsCollegeCell
        };

        foreach (var pair in refMapping.Cell1ToCell2)
        {
            map[pair.Key] = pair.Value;
        }

        return map;
    }

    private static int RemapLinksInTransferredPlacedRecords(
        ICell? bceCellOverride,
        IEnumerable<FormKey> transferredRefs,
        IReadOnlyDictionary<FormKey, FormKey> swapMap,
        HashSet<FormKey> intentionallyModifiedFormKeys,
        out int swappedRecords)
    {
        swappedRecords = 0;
        if (bceCellOverride is null)
        {
            return 0;
        }

        var swappedLinks = 0;
        foreach (var formKey in transferredRefs)
        {
            if (!TryGetPatchedPlacedByFormKey(bceCellOverride, formKey, out var patchedPlaced)
                || patchedPlaced is not IFormLinkContainer patchedPlacedWithLinks)
            {
                continue;
            }

            var matchedLinksInRecord = patchedPlacedWithLinks
                .EnumerateFormLinks()
                .Count(link => swapMap.ContainsKey(link.FormKey));
            if (matchedLinksInRecord == 0)
            {
                continue;
            }

            patchedPlacedWithLinks.RemapLinks(swapMap);
            swappedLinks += matchedLinksInRecord;
            swappedRecords++;
            intentionallyModifiedFormKeys.Add(bceCellOverride.FormKey);
            intentionallyModifiedFormKeys.Add(patchedPlaced.FormKey);
        }

        return swappedLinks;
    }

    private static void CleanupUnintentionalPatchRecords(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        HashSet<FormKey> intentionallyModifiedFormKeys,
        Settings settings)
    {
        var patchRecordsByKey = state.PatchMod
            .EnumerateMajorRecords()
            .ToDictionary(record => record.FormKey, record => record);

        if (settings.Debug)
        {
            var hasDebugBceExteriorBeforeCleanup = patchRecordsByKey.ContainsKey(DebugBceExteriorDoor020FFE);
            var debugBceExteriorIsIntentional = intentionallyModifiedFormKeys.Contains(DebugBceExteriorDoor020FFE);
            Console.WriteLine(
                $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Cleanup debug: {DebugBceExteriorDoor020FFE} presentBefore={hasDebugBceExteriorBeforeCleanup} intentional={debugBceExteriorIsIntentional}.");
        }

        var allPatchRecordKeys = patchRecordsByKey.Keys.ToHashSet();

        var totalBeforeCleanup = allPatchRecordKeys.Count;
        allPatchRecordKeys.ExceptWith(intentionallyModifiedFormKeys);
        var removableKeys = allPatchRecordKeys
            .Where(formKey =>
                patchRecordsByKey.TryGetValue(formKey, out var record)
                && record is not ICellGetter
                && record is not IWorldspaceGetter)
            .ToHashSet();

        var removedCount = removableKeys.Count;
        if (removedCount > 0)
        {
            state.PatchMod.Remove(removableKeys);
        }

        if (settings.Debug)
        {
            var hasDebugBceExteriorAfterCleanup = state.PatchMod
                .EnumerateMajorRecords()
                .Any(record => record.FormKey == DebugBceExteriorDoor020FFE);
            Console.WriteLine(
                $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Cleanup debug: {DebugBceExteriorDoor020FFE} presentAfter={hasDebugBceExteriorAfterCleanup}.");
        }

        var keptCount = totalBeforeCleanup - removedCount;
        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Cleanup: kept {keptCount} intentional records, removed {removedCount} non-intentional records.");
    }

    private static void SyncPatchHeaderRecordCount(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings)
    {
        var modHeaderCommon = (IModHeaderCommon)state.PatchMod.ModHeader;
        var previousCount = modHeaderCommon.NumRecords;
        var actualCount = state.PatchMod.GetRecordCount();
        modHeaderCommon.NumRecords = actualCount;

        if (settings.Debug)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Header record count sync: {previousCount} -> {actualCount}.");
        }
    }

    private sealed record InteriorDoorPair(
        FormKey VanillaInteriorDoor,
        FormKey BceInteriorDoor,
        bool VanillaInteriorDisabled);

    private static void RewireMovedReplacementDoorsForBardsCollege(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        HashSet<FormKey> intentionallyModifiedFormKeys,
        RefMapping bardsRefMapping,
        HashSet<FormKey> movedBardsReferences)
    {
        var bceCellOverride = GetBceCellOverrideOrNull(state, BceBardsCollegeCell);
        if (bceCellOverride is null)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Door replacement (Bards College): skipped (BCE cell override unavailable).");
            return;
        }

        var pairIndex = BuildInteriorDoorPairIndexByExteriorTarget(state, settings, bardsRefMapping);
        if (pairIndex.Count == 0)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Door replacement (Bards College): no mapped interior door pairs with exterior targets.");
            return;
        }

        var evaluatedCandidates = 0;
        var matchedCandidates = 0;
        var patchedCandidates = 0;
        var skippedByReason = new Dictionary<string, int>(StringComparer.Ordinal);

        static void IncrementSkip(Dictionary<string, int> counters, string reason)
        {
            if (!counters.TryAdd(reason, 1))
            {
                counters[reason]++;
            }
        }

        foreach (var movedFormKey in movedBardsReferences)
        {
            if (!TryGetPatchedPlacedObjectByFormKey(bceCellOverride, movedFormKey, out var movedDoor))
            {
                IncrementSkip(skippedByReason, "moved_ref_not_in_bce_cell");
                continue;
            }

            if (!IsPlacedDoor(state, movedDoor))
            {
                IncrementSkip(skippedByReason, "moved_ref_not_door");
                continue;
            }

            evaluatedCandidates++;
            if (!TryGetTeleportDoorTarget(movedDoor, out var targetVanillaExteriorDoor))
            {
                IncrementSkip(skippedByReason, "moved_door_missing_teleport_target");
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Door replacement: skipped {movedDoor.FormKey} (no teleport door target).");
                }

                continue;
            }

            if (!pairIndex.TryGetValue(targetVanillaExteriorDoor, out var pairsForExterior))
            {
                IncrementSkip(skippedByReason, "no_mapped_pair_for_exterior_target");
                continue;
            }

            if (!TryResolveReplacementPair(pairsForExterior, out var selectedPair, out var pairSkipReason))
            {
                IncrementSkip(skippedByReason, pairSkipReason);
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Door replacement: skipped {movedDoor.FormKey} ({pairSkipReason}).");
                }

                continue;
            }

            matchedCandidates++;
            if (settings.Debug)
            {
                Console.WriteLine(
                    $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Door replacement: candidate {movedDoor.FormKey} matched vanilla {selectedPair.VanillaInteriorDoor} / BCE {selectedPair.BceInteriorDoor} via exterior {targetVanillaExteriorDoor}.");
            }

            var isDebugPair = settings.Debug && IsDebugDoorPair(selectedPair.VanillaInteriorDoor, selectedPair.BceInteriorDoor);
            if (isDebugPair)
            {
                Console.WriteLine(
                    $"[{nameof(BardsCollegeExpansionAutoPatcher)}] DebugPair 0006AE55/0501F42F (selected): movedDoor={movedDoor.FormKey} movedBucket={GetCellBucketLabel(bceCellOverride, movedDoor.FormKey)} movedNavDoorLink={movedDoor.NavigationDoorLink is not null} movedLocationRefType={HasNonNullProperty(movedDoor, "LocationRefType")}.");
            }

            if (!TryGetSourcePlacedObjectRecord(state, selectedPair.BceInteriorDoor, selectedPair.BceInteriorDoor.ModKey, out var bceInteriorDoorSource))
            {
                IncrementSkip(skippedByReason, "bce_interior_source_unresolvable");
                if (isDebugPair)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] DebugPair 0006AE55/0501F42F: abort bce_interior_source_unresolvable.");
                }

                continue;
            }

            if (!TryGetPatchedPlacedObjectByFormKey(bceCellOverride, selectedPair.BceInteriorDoor, out var bceInteriorDoor))
            {
                IncrementSkip(skippedByReason, "bce_interior_door_not_found_in_bce_cell");
                if (isDebugPair)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] DebugPair 0006AE55/0501F42F: abort bce_interior_door_not_found_in_bce_cell.");
                }

                continue;
            }

            if (!IsPlacedDoor(state, bceInteriorDoor))
            {
                IncrementSkip(skippedByReason, "bce_interior_ref_not_door");
                if (isDebugPair)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] DebugPair 0006AE55/0501F42F: abort bce_interior_ref_not_door base={bceInteriorDoor.Base.FormKey}.");
                }

                continue;
            }

            // Use the BCE master/source link target to avoid phase-3-mutated targets in the working override.
            if (!TryGetTeleportDoorTarget(bceInteriorDoorSource, out var bceExteriorDoorFormKey))
            {
                IncrementSkip(skippedByReason, "bce_interior_missing_exterior_target");
                if (isDebugPair)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] DebugPair 0006AE55/0501F42F: abort bce_interior_missing_exterior_target.");
                }

                continue;
            }

            if (!bceExteriorDoorFormKey
                    .ToLink<IPlacedObjectGetter>()
                    .TryResolveContext<ISkyrimMod, ISkyrimModGetter, IPlacedObject, IPlacedObjectGetter>(state.LinkCache, out var bceExteriorContext))
            {
                IncrementSkip(skippedByReason, "bce_exterior_door_unresolvable");
                if (isDebugPair)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] DebugPair 0006AE55/0501F42F: abort bce_exterior_door_unresolvable target={bceExteriorDoorFormKey}.");
                }

                continue;
            }

            var bceExteriorDoorOverride = bceExteriorContext.GetOrAddAsOverride(state.PatchMod);
            if (!IsPlacedDoor(state, bceExteriorDoorOverride))
            {
                IncrementSkip(skippedByReason, "bce_exterior_ref_not_door");
                if (isDebugPair)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] DebugPair 0006AE55/0501F42F: abort bce_exterior_ref_not_door base={bceExteriorDoorOverride.Base.FormKey}.");
                }

                continue;
            }

            if (movedDoor.TeleportDestination is null)
            {
                IncrementSkip(skippedByReason, "moved_door_missing_teleport_destination_object");
                if (isDebugPair)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] DebugPair 0006AE55/0501F42F: abort moved_door_missing_teleport_destination_object.");
                }

                continue;
            }

            if (bceExteriorDoorOverride.TeleportDestination is null)
            {
                IncrementSkip(skippedByReason, "bce_exterior_missing_teleport_destination_object");
                if (isDebugPair)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] DebugPair 0006AE55/0501F42F: abort bce_exterior_missing_teleport_destination_object.");
                }

                continue;
            }

            // All required records and links resolved, apply atomically.
            var disabledBefore = IsPlacedInitiallyDisabled(bceInteriorDoor);
            var disableApplied = TryDisablePlacedDoorIdempotent(bceInteriorDoor);
            var disabledAfter = IsPlacedInitiallyDisabled(bceInteriorDoor);
            movedDoor.TeleportDestination.Door.SetTo(bceExteriorDoorFormKey);
            bceExteriorDoorOverride.TeleportDestination.Door.SetTo(movedDoor.FormKey);

            var bceExteriorDoorActualTarget = bceExteriorDoorOverride.TeleportDestination.Door.FormKey;
            if (bceExteriorDoorActualTarget != movedDoor.FormKey)
            {
                IncrementSkip(skippedByReason, "bce_exterior_rewire_not_applied");
                if (isDebugPair)
                {
                    Console.WriteLine(
                        $"[{nameof(BardsCollegeExpansionAutoPatcher)}] DebugPair 0006AE55/0501F42F: abort bce_exterior_rewire_not_applied expected={movedDoor.FormKey} actual={bceExteriorDoorActualTarget}.");
                }

                continue;
            }

            if (isDebugPair)
            {
                Console.WriteLine(
                    $"[{nameof(BardsCollegeExpansionAutoPatcher)}] DebugPair 0006AE55/0501F42F (patched): bceInterior={bceInteriorDoor.FormKey} bucket={GetCellBucketLabel(bceCellOverride, bceInteriorDoor.FormKey)} navDoorLink={bceInteriorDoor.NavigationDoorLink is not null} locationRefType={HasNonNullProperty(bceInteriorDoor, "LocationRefType")} disabledBefore={disabledBefore} disableApplied={disableApplied} disabledAfter={disabledAfter}; bceExterior={bceExteriorDoorOverride.FormKey} bceExteriorTarget={bceExteriorDoorActualTarget} expected={movedDoor.FormKey}.");
            }

            patchedCandidates++;
            intentionallyModifiedFormKeys.Add(bceCellOverride.FormKey);
            intentionallyModifiedFormKeys.Add(movedDoor.FormKey);
            intentionallyModifiedFormKeys.Add(bceInteriorDoor.FormKey);
            intentionallyModifiedFormKeys.Add(bceExteriorDoorOverride.FormKey);

            if (settings.Debug)
            {
                Console.WriteLine(
                    $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Door replacement: patched moved {movedDoor.FormKey}, disabled BCE interior {bceInteriorDoor.FormKey}, rewired BCE exterior {bceExteriorDoorOverride.FormKey}.");
            }
        }

        var skipSummary = skippedByReason.Count == 0
            ? "none"
            : string.Join(", ", skippedByReason.OrderBy(x => x.Key).Select(x => $"{x.Key}={x.Value}"));
        Console.WriteLine(
            $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Door replacement (Bards College): evaluated {evaluatedCandidates}, matched {matchedCandidates}, patched {patchedCandidates}, skipped [{skipSummary}].");
    }

    private static Dictionary<FormKey, List<InteriorDoorPair>> BuildInteriorDoorPairIndexByExteriorTarget(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        RefMapping bardsRefMapping)
    {
        var index = new Dictionary<FormKey, List<InteriorDoorPair>>();

        foreach (var pair in bardsRefMapping.Cell1ToCell2)
        {
            if (!TryGetSourcePlacedObjectRecord(state, pair.Key, pair.Key.ModKey, out var vanillaInteriorDoorSource))
            {
                continue;
            }

            if (!TryGetSourcePlacedObjectRecord(state, pair.Value, pair.Value.ModKey, out var bceInteriorDoorSource))
            {
                continue;
            }

            if (!IsPlacedDoor(state, vanillaInteriorDoorSource) || !IsPlacedDoor(state, bceInteriorDoorSource))
            {
                continue;
            }

            // Match against the source vanilla destination so replacement doors that mirror
            // original vanilla links can still map even if winning overrides changed that record.
            if (!TryGetTeleportDoorTarget(vanillaInteriorDoorSource, out var targetVanillaExteriorDoor))
            {
                continue;
            }

            if (!TryGetTeleportDoorTarget(bceInteriorDoorSource, out _))
            {
                continue;
            }

            var vanillaInteriorDisabled = IsPlacedInitiallyDisabled(vanillaInteriorDoorSource);
            var vanillaInteriorWinningDisabled = pair.Key
                .ToLink<IPlacedObjectGetter>()
                .TryResolveContext<ISkyrimMod, ISkyrimModGetter, IPlacedObject, IPlacedObjectGetter>(state.LinkCache, out var vanillaInteriorWinningContext)
                && IsPlacedInitiallyDisabled(vanillaInteriorWinningContext.Record);
            var vanillaInteriorWinningMod = vanillaInteriorWinningContext?.ModKey.ToString() ?? "unresolved";

            var candidate = new InteriorDoorPair(
                VanillaInteriorDoor: vanillaInteriorDoorSource.FormKey,
                BceInteriorDoor: bceInteriorDoorSource.FormKey,
                VanillaInteriorDisabled: vanillaInteriorDisabled);

            if (settings.Debug && IsDebugDoorPair(candidate.VanillaInteriorDoor, candidate.BceInteriorDoor))
            {
                var vanillaHasNavDoorLink = vanillaInteriorDoorSource.NavigationDoorLink is not null;
                var bceHasNavDoorLink = bceInteriorDoorSource.NavigationDoorLink is not null;
                var vanillaHasLocationRefType = HasNonNullProperty(vanillaInteriorDoorSource, "LocationRefType");
                var bceHasLocationRefType = HasNonNullProperty(bceInteriorDoorSource, "LocationRefType");
                Console.WriteLine(
                    $"[{nameof(BardsCollegeExpansionAutoPatcher)}] DebugPair 0006AE55/0501F42F (index): vanilla={candidate.VanillaInteriorDoor} disabledSource={vanillaInteriorDisabled} disabledWinning={vanillaInteriorWinningDisabled} winningMod={vanillaInteriorWinningMod} navDoorLink={vanillaHasNavDoorLink} locationRefType={vanillaHasLocationRefType}; bce={candidate.BceInteriorDoor} navDoorLink={bceHasNavDoorLink} locationRefType={bceHasLocationRefType}; exteriorTarget={targetVanillaExteriorDoor}.");
            }

            if (!index.TryGetValue(targetVanillaExteriorDoor, out var list))
            {
                list = [];
                index[targetVanillaExteriorDoor] = list;
            }

            list.Add(candidate);
        }

        if (settings.Debug)
        {
            Console.WriteLine(
                $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Door replacement: indexed {index.Sum(x => x.Value.Count)} mapped interior pairs across {index.Count} exterior targets.");
        }

        return index;
    }

    private static bool TryGetSourcePlacedObjectRecord(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        FormKey formKey,
        ModKey sourceModKey,
        out IPlacedObjectGetter record)
    {
        var sourceContext = formKey
            .ToLink<IPlacedObjectGetter>()
            .ResolveAllSimpleContexts<IPlacedObjectGetter>(state.LinkCache)
            .FirstOrDefault(x => x.ModKey == sourceModKey);

        if (sourceContext is null)
        {
            record = null!;
            return false;
        }

        record = sourceContext.Record;
        return true;
    }

    private static bool TryResolveReplacementPair(
        IReadOnlyList<InteriorDoorPair> candidates,
        out InteriorDoorPair selectedPair,
        out string skipReason)
    {
        selectedPair = default!;
        skipReason = string.Empty;

        if (candidates.Count == 0)
        {
            skipReason = "no_candidates_for_exterior_target";
            return false;
        }

        if (candidates.Count == 1)
        {
            selectedPair = candidates[0];
            return true;
        }

        var disabledCandidates = candidates.Where(x => x.VanillaInteriorDisabled).ToList();
        if (disabledCandidates.Count == 1)
        {
            selectedPair = disabledCandidates[0];
            return true;
        }

        skipReason = disabledCandidates.Count > 1
            ? "ambiguous_multiple_disabled_candidates"
            : "ambiguous_multiple_candidates_no_disabled";
        return false;
    }

    private static bool IsPlacedDoor(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        IPlacedObjectGetter placedObject)
    {
        var baseFormKey = placedObject.Base.FormKey;
        return !baseFormKey.IsNull && state.LinkCache.TryResolve<IDoorGetter>(baseFormKey, out _);
    }

    private static bool TryGetTeleportDoorTarget(IPlacedObjectGetter placedObject, out FormKey doorTarget)
    {
        doorTarget = default;
        var teleportDestination = placedObject.TeleportDestination;
        if (teleportDestination is null)
        {
            return false;
        }

        var target = teleportDestination.Door.FormKey;
        if (target.IsNull)
        {
            return false;
        }

        doorTarget = target;
        return true;
    }

    private static bool TryDisablePlacedDoorIdempotent(IPlacedObject placedDoor)
    {
        if (IsPlacedInitiallyDisabled(placedDoor))
        {
            return false;
        }

        placedDoor.Disable(IPlaced.DisableType.JustInitiallyDisabled);
        return true;
    }

    private static bool IsPlacedInitiallyDisabled(object placed)
    {
        foreach (var propertyName in new[] { "MajorFlags", "Flags" })
        {
            var property = placed.GetType().GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);
            if (property is null || !property.CanRead)
            {
                continue;
            }

            var value = property.GetValue(placed);
            if (value is null)
            {
                continue;
            }

            if (value is Enum enumValue)
            {
                if (TryHasInitiallyDisabledEnumFlag(enumValue))
                {
                    return true;
                }
            }

            var text = value.ToString();
            if (IsInitiallyDisabledFlagName(text))
            {
                return true;
            }
        }

        return false;
    }

    private static bool TryHasInitiallyDisabledEnumFlag(Enum enumValue)
    {
        var enumText = enumValue.ToString();
        if (IsInitiallyDisabledFlagName(enumText))
        {
            return true;
        }

        try
        {
            var enumType = enumValue.GetType();
            var rawValue = Convert.ToUInt64(enumValue, CultureInfo.InvariantCulture);
            if (rawValue == 0)
            {
                return false;
            }

            foreach (var candidate in Enum.GetValues(enumType))
            {
                if (candidate is not Enum candidateEnum)
                {
                    continue;
                }

                var candidateName = Enum.GetName(enumType, candidate);
                if (!IsInitiallyDisabledFlagName(candidateName))
                {
                    continue;
                }

                var candidateRaw = Convert.ToUInt64(candidateEnum, CultureInfo.InvariantCulture);
                if (candidateRaw == 0)
                {
                    continue;
                }

                if ((rawValue & candidateRaw) == candidateRaw)
                {
                    return true;
                }
            }
        }
        catch
        {
            // Fallback to string-based detection when raw enum conversion is unavailable.
        }

        return false;
    }

    private static bool IsInitiallyDisabledFlagName(string? text)
    {
        if (string.IsNullOrWhiteSpace(text))
        {
            return false;
        }

        var normalized = string.Concat(text.Where(char.IsLetterOrDigit));
        return normalized.Contains("InitiallyDisabled", StringComparison.OrdinalIgnoreCase);
    }

    private static bool IsDebugDoorPair(FormKey vanillaDoor, FormKey bceDoor)
    {
        return vanillaDoor == DebugVanillaDoor0006AE55 && bceDoor == DebugBceDoor0501F42F;
    }

    private static string GetCellBucketLabel(ICellGetter cell, FormKey formKey)
    {
        if (cell.Persistent.Any(x => x.FormKey == formKey))
        {
            return "persistent";
        }

        if (cell.Temporary.Any(x => x.FormKey == formKey))
        {
            return "temporary";
        }

        return "not-found";
    }

    private static bool HasNonNullProperty(object target, string propertyName)
    {
        var property = target.GetType().GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);
        return property is not null && property.CanRead && property.GetValue(target) is not null;
    }

    private static void RemapBardsCollegeNavigationDoorLinks(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        HashSet<FormKey> intentionallyModifiedFormKeys,
        HashSet<FormKey> movedBardsReferences)
    {
        var bceCellOverride = GetBceCellOverrideOrNull(state, BceBardsCollegeCell);
        if (bceCellOverride is null)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 5 (Bards College): skipped navdoor remap (BCE cell override unavailable).");
            return;
        }

        var vanillaNavmeshCentroids = BuildCellNavmeshCentroids(state, VanillaBardsCollegeCell);
        var bceNavmeshCentroids = BuildCellNavmeshCentroids(state, BceBardsCollegeCell);

        if (vanillaNavmeshCentroids.Count == 0 || bceNavmeshCentroids.Count == 0)
        {
            Console.WriteLine(
                $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 5 (Bards College): skipped navdoor remap (vanilla navmeshes: {vanillaNavmeshCentroids.Count}, BCE navmeshes: {bceNavmeshCentroids.Count}).");
            return;
        }

        var navmeshSwapMap = MatchNavmeshesByClosestCentroid(vanillaNavmeshCentroids, bceNavmeshCentroids);
        if (navmeshSwapMap.Count == 0)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 5 (Bards College): no navmesh centroid matches found.");
            return;
        }

        var evaluatedDoors = 0;
        var remappedDoors = 0;
        var triangleExistingMatch = 0;
        var triangleSynthesizedFromNearestNonDoor = 0;
        var triangleFallbackFromDoorPosition = 0;
        var triangleSetToNegativeOne = 0;
        foreach (var movedFormKey in movedBardsReferences)
        {
            if (!TryGetPatchedPlacedObjectByFormKey(bceCellOverride, movedFormKey, out var patchedDoor))
            {
                continue;
            }

            if (!state.LinkCache.TryResolve<IDoorGetter>(patchedDoor.Base.FormKey, out _))
            {
                continue;
            }

            var doorLink = patchedDoor.NavigationDoorLink;
            if (doorLink is null)
            {
                continue;
            }

            evaluatedDoors++;
            var linkedNavmesh = doorLink.NavMesh.FormKey;
            if (!navmeshSwapMap.TryGetValue(linkedNavmesh, out var targetNavmesh))
            {
                continue;
            }

            var oldTriangle = doorLink.TeleportMarkerTriangle;
            var resolvedTriangle = (short)-1;
            var triangleResolutionSource = "fallback_negative_one";

            if (targetNavmesh
                .ToLink<INavigationMeshGetter>()
                .TryResolveContext<ISkyrimMod, ISkyrimModGetter, INavigationMesh, INavigationMeshGetter>(state.LinkCache, out var targetNavmeshContext))
            {
                var targetNavmeshOverride = targetNavmeshContext.GetOrAddAsOverride(state.PatchMod);
                if (TryResolveOrCreateDoorTriangleForDoor(
                        state,
                        patchedDoor,
                        linkedNavmesh,
                        oldTriangle,
                        targetNavmeshOverride,
                        out var synthesizedTriangle,
                        out triangleResolutionSource))
                {
                    resolvedTriangle = synthesizedTriangle;

                    if (string.Equals(triangleResolutionSource, "existing_match", StringComparison.Ordinal))
                    {
                        triangleExistingMatch++;
                    }
                    else if (string.Equals(triangleResolutionSource, "synthesized_from_nearest_non_door", StringComparison.Ordinal))
                    {
                        triangleSynthesizedFromNearestNonDoor++;
                        intentionallyModifiedFormKeys.Add(targetNavmeshOverride.FormKey);
                    }
                    else if (string.Equals(triangleResolutionSource, "fallback_from_door_position", StringComparison.Ordinal))
                    {
                        triangleFallbackFromDoorPosition++;
                        intentionallyModifiedFormKeys.Add(targetNavmeshOverride.FormKey);
                    }
                }
                else
                {
                    triangleSetToNegativeOne++;
                }
            }
            else
            {
                triangleSetToNegativeOne++;
            }

            doorLink.NavMesh.SetTo(targetNavmesh);
            doorLink.TeleportMarkerTriangle = resolvedTriangle;
            remappedDoors++;
            intentionallyModifiedFormKeys.Add(bceCellOverride.FormKey);
            intentionallyModifiedFormKeys.Add(patchedDoor.FormKey);

            if (settings.Debug)
            {
                Console.WriteLine(
                    $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 5 (Bards College): remapped moved door {patchedDoor.FormKey} navdoor {linkedNavmesh} -> {targetNavmesh}; triangle {oldTriangle} -> {resolvedTriangle} ({triangleResolutionSource}).");
            }
        }

        Console.WriteLine(
            $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 5 (Bards College): matched {navmeshSwapMap.Count} navmeshes, evaluated {evaluatedDoors} moved-door links, remapped {remappedDoors}, triangle_existing_match={triangleExistingMatch}, triangle_synthesized_from_nearest_non_door={triangleSynthesizedFromNearestNonDoor}, triangle_fallback_from_door_position={triangleFallbackFromDoorPosition}, triangle_set_to_negative_one={triangleSetToNegativeOne}.");
    }

    private static Dictionary<FormKey, (double X, double Y, double Z)> BuildCellNavmeshCentroids(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        FormKey cellFormKey)
    {
        var result = new Dictionary<FormKey, (double X, double Y, double Z)>();

        foreach (var navmeshContext in state.LoadOrder.PriorityOrder
                     .WinningContextOverrides<ISkyrimMod, ISkyrimModGetter, INavigationMesh, INavigationMeshGetter>(state.LinkCache))
        {
            var parent = navmeshContext.Record.Data?.Parent;
            if (parent is not ICellNavmeshParentGetter cellParent)
            {
                continue;
            }

            if (cellParent.Parent.FormKey != cellFormKey)
            {
                continue;
            }

            var centroid = TryComputeNavmeshCentroid(navmeshContext.Record);
            if (centroid is null)
            {
                continue;
            }

            result[navmeshContext.Record.FormKey] = centroid.Value;
        }

        return result;
    }

    private static (double X, double Y, double Z)? TryComputeNavmeshCentroid(INavigationMeshGetter navmesh)
    {
        var vertices = navmesh.Data?.Vertices;
        if (vertices is null || vertices.Count == 0)
        {
            return null;
        }

        double x = 0;
        double y = 0;
        double z = 0;
        foreach (var vertex in vertices)
        {
            x += vertex.X;
            y += vertex.Y;
            z += vertex.Z;
        }

        var count = vertices.Count;
        return (x / count, y / count, z / count);
    }

    private static Dictionary<FormKey, FormKey> MatchNavmeshesByClosestCentroid(
        Dictionary<FormKey, (double X, double Y, double Z)> vanillaNavmeshCentroids,
        Dictionary<FormKey, (double X, double Y, double Z)> bceNavmeshCentroids)
    {
        var candidatePairs = new List<(FormKey Vanilla, FormKey Bce, double DistanceSquared)>();
        foreach (var vanilla in vanillaNavmeshCentroids)
        {
            foreach (var bce in bceNavmeshCentroids)
            {
                candidatePairs.Add((vanilla.Key, bce.Key, DistanceSquared(vanilla.Value, bce.Value)));
            }
        }

        var matchedVanilla = new HashSet<FormKey>();
        var matchedBce = new HashSet<FormKey>();
        var map = new Dictionary<FormKey, FormKey>();

        foreach (var pair in candidatePairs.OrderBy(x => x.DistanceSquared))
        {
            if (!matchedVanilla.Add(pair.Vanilla))
            {
                continue;
            }

            if (!matchedBce.Add(pair.Bce))
            {
                continue;
            }

            map[pair.Vanilla] = pair.Bce;
        }

        return map;
    }

    private static double DistanceSquared((double X, double Y, double Z) left, (double X, double Y, double Z) right)
    {
        var dx = left.X - right.X;
        var dy = left.Y - right.Y;
        var dz = left.Z - right.Z;
        return dx * dx + dy * dy + dz * dz;
    }

    private static bool TryResolveOrCreateDoorTriangleForDoor(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        IPlacedObject patchedDoor,
        FormKey sourceNavmesh,
        short sourceTriangle,
        INavigationMesh targetNavmeshOverride,
        out short triangle,
        out string resolutionSource)
    {
        triangle = -1;
        resolutionSource = "fallback_negative_one";

        if (TryGetExistingDoorTriangleForDoor(targetNavmeshOverride, patchedDoor.FormKey, out var existingTriangle))
        {
            triangle = existingTriangle;
            resolutionSource = "existing_match";
            return true;
        }

        if (TryGetTriangleCentroidFromLink(state, sourceNavmesh, sourceTriangle, out var sourceTriangleCentroid)
            && TryFindNearestAvailableTriangle(targetNavmeshOverride, sourceTriangleCentroid, out var nearestTriangle))
        {
            if (TryAppendDoorTriangle(targetNavmeshOverride, patchedDoor.FormKey, nearestTriangle))
            {
                triangle = nearestTriangle;
                resolutionSource = "synthesized_from_nearest_non_door";
                return true;
            }
        }

        if (TryGetPlacedObjectPosition(patchedDoor, out var doorPosition)
            && TryFindNearestAvailableTriangle(targetNavmeshOverride, doorPosition, out var fallbackTriangle)
            && TryAppendDoorTriangle(targetNavmeshOverride, patchedDoor.FormKey, fallbackTriangle))
        {
            triangle = fallbackTriangle;
            resolutionSource = "fallback_from_door_position";
            return true;
        }

        return false;
    }

    private static bool TryGetExistingDoorTriangleForDoor(INavigationMeshGetter navmesh, FormKey doorFormKey, out short triangle)
    {
        triangle = -1;
        var doorTriangles = navmesh.Data?.DoorTriangles;
        if (doorTriangles is null || doorTriangles.Count == 0)
        {
            return false;
        }

        foreach (var doorTriangle in doorTriangles)
        {
            if (doorTriangle.Door.FormKey != doorFormKey)
            {
                continue;
            }

            triangle = doorTriangle.TriangleBeforeDoor;
            return true;
        }

        return false;
    }

    private static bool TryGetTriangleCentroidFromLink(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        FormKey navmeshFormKey,
        short triangleIndex,
        out (double X, double Y, double Z) centroid)
    {
        centroid = default;
        if (!state.LinkCache.TryResolve<INavigationMeshGetter>(navmeshFormKey, out var navmesh))
        {
            return false;
        }

        return TryGetTriangleCentroid(navmesh, triangleIndex, out centroid);
    }

    private static bool TryGetTriangleCentroid(
        INavigationMeshGetter navmesh,
        short triangleIndex,
        out (double X, double Y, double Z) centroid)
    {
        centroid = default;
        var data = navmesh.Data;
        if (data is null)
        {
            return false;
        }

        if (triangleIndex < 0)
        {
            return false;
        }

        return TryGetTriangleCentroid(data, triangleIndex, out centroid);
    }

    private static bool TryGetTriangleCentroid(
        INavigationMeshDataGetter data,
        int triangleIndex,
        out (double X, double Y, double Z) centroid)
    {
        centroid = default;
        var vertices = data.Vertices;
        var triangles = data.Triangles;
        if (vertices is null || triangles is null)
        {
            return false;
        }

        if (triangleIndex < 0 || triangleIndex >= triangles.Count)
        {
            return false;
        }

        var navTriangle = triangles[triangleIndex];
        var a = navTriangle.Vertices.X;
        var b = navTriangle.Vertices.Y;
        var c = navTriangle.Vertices.Z;
        if (a < 0 || b < 0 || c < 0 || a >= vertices.Count || b >= vertices.Count || c >= vertices.Count)
        {
            return false;
        }

        var va = vertices[a];
        var vb = vertices[b];
        var vc = vertices[c];
        centroid = (
            (va.X + vb.X + vc.X) / 3d,
            (va.Y + vb.Y + vc.Y) / 3d,
            (va.Z + vb.Z + vc.Z) / 3d);
        return true;
    }

    private static bool TryFindNearestAvailableTriangle(
        INavigationMeshGetter navmesh,
        (double X, double Y, double Z) referencePoint,
        out short triangle)
    {
        triangle = -1;
        var data = navmesh.Data;
        if (data is null)
        {
            return false;
        }

        var triangles = data.Triangles;
        if (triangles is null || triangles.Count == 0)
        {
            return false;
        }

        var usedDoorTriangles = new HashSet<int>();
        var doorTriangles = data.DoorTriangles;
        if (doorTriangles is not null)
        {
            foreach (var doorTriangle in doorTriangles)
            {
                usedDoorTriangles.Add(doorTriangle.TriangleBeforeDoor);
            }
        }

        var found = false;
        var bestDistance = double.MaxValue;
        var bestTriangle = -1;

        for (var i = 0; i < triangles.Count; i++)
        {
            if (usedDoorTriangles.Contains(i))
            {
                continue;
            }

            if (!TryGetTriangleCentroid(data, i, out var triangleCentroid))
            {
                continue;
            }

            var distance = DistanceSquared(referencePoint, triangleCentroid);
            if (distance >= bestDistance)
            {
                continue;
            }

            bestDistance = distance;
            bestTriangle = i;
            found = true;
        }

        if (!found || bestTriangle > short.MaxValue)
        {
            return false;
        }

        triangle = (short)bestTriangle;
        return true;
    }

    private static bool TryGetMostCommonDoorTriangleUnknown(INavigationMeshGetter navmesh, out int unknown)
    {
        unknown = 0;
        var doorTriangles = navmesh.Data?.DoorTriangles;
        if (doorTriangles is null || doorTriangles.Count == 0)
        {
            return false;
        }

        unknown = doorTriangles
            .GroupBy(x => x.Unknown)
            .OrderByDescending(group => group.Count())
            .ThenBy(group => group.Key)
            .First()
            .Key;
        return true;
    }

    private static bool TryAppendDoorTriangle(INavigationMesh navmesh, FormKey doorFormKey, short triangle)
    {
        if (navmesh.Data is null)
        {
            return false;
        }

        if (TryGetExistingDoorTriangleForDoor(navmesh, doorFormKey, out _))
        {
            return true;
        }

        TryGetMostCommonDoorTriangleUnknown(navmesh, out var unknown);
        var doorTriangle = new DoorTriangle
        {
            TriangleBeforeDoor = triangle,
            Unknown = unknown
        };
        doorTriangle.Door.SetTo(doorFormKey);
        navmesh.Data.DoorTriangles.Add(doorTriangle);
        return true;
    }

    private static bool TryGetPlacedObjectPosition(IPlacedObjectGetter placedObject, out (double X, double Y, double Z) position)
    {
        position = default;
        var placement = placedObject.Placement;
        if (placement is null)
        {
            return false;
        }

        return TryReadVector3(placement, "Position", out position);
    }

    private static ICell? GetBceCellOverrideOrNull(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        FormKey bceCellFormKey)
    {
        var bceCellContext = state.LoadOrder.PriorityOrder
            .Cell()
            .WinningContextOverrides(state.LinkCache)
            .FirstOrDefault(x => x.Record.FormKey == bceCellFormKey);

        return bceCellContext?.GetOrAddAsOverride(state.PatchMod);
    }

    private static bool TryGetPatchedPlacedByFormKey(ICell cell, FormKey formKey, out IPlaced placed)
    {
        foreach (var entry in cell.Persistent)
        {
            if (entry.FormKey != formKey)
            {
                continue;
            }

            placed = entry;
            return true;
        }

        foreach (var entry in cell.Temporary)
        {
            if (entry.FormKey != formKey)
            {
                continue;
            }

            placed = entry;
            return true;
        }

        placed = null!;
        return false;
    }

    private static bool TryGetPatchedPlacedObjectByFormKey(ICell cell, FormKey formKey, out IPlacedObject placedObject)
    {
        if (TryGetPatchedPlacedByFormKey(cell, formKey, out var placed) && placed is IPlacedObject door)
        {
            placedObject = door;
            return true;
        }

        placedObject = null!;
        return false;
    }

    private static bool HaveMatchingPlacedKind(object left, object right)
    {
        return GetPlacedKind(left) == GetPlacedKind(right);
    }

    private static string GetPlacedKind(object value)
    {
        return value switch
        {
            IPlacedObjectGetter => "PlacedObject",
            IPlacedNpcGetter => "PlacedNpc",
            IAPlacedTrapGetter => "PlacedTrap",
            _ => "Unknown"
        };
    }

    private static bool ApplyChangedProperties(object originalRecord, object winningRecord, object targetRecord, Settings settings)
    {
        var changedAny = false;
        var targetType = targetRecord.GetType();
        var originalType = originalRecord.GetType();
        var winningType = winningRecord.GetType();

        foreach (var targetProperty in targetType.GetProperties())
        {
            if (!targetProperty.CanRead || !targetProperty.CanWrite)
            {
                continue;
            }

            if (targetProperty.GetIndexParameters().Length > 0)
            {
                continue;
            }

            if (targetProperty.Name is "FormKey" or "EditorID")
            {
                continue;
            }

            if (!SyncedPlacedPropertyNames.Contains(targetProperty.Name))
            {
                continue;
            }

            var originalProperty = originalType.GetProperty(targetProperty.Name);
            var winningProperty = winningType.GetProperty(targetProperty.Name);
            if (originalProperty is null || winningProperty is null || !originalProperty.CanRead || !winningProperty.CanRead)
            {
                continue;
            }

            var originalValue = originalProperty.GetValue(originalRecord);
            var winningValue = winningProperty.GetValue(winningRecord);

            if (ValuesEqual(originalValue, winningValue))
            {
                continue;
            }

            if (string.Equals(targetProperty.Name, "Placement", StringComparison.Ordinal))
            {
                if (TryAssignPlacement(targetRecord, targetProperty, winningValue, settings))
                {
                    changedAny = true;
                }

                continue;
            }

            if (string.Equals(targetProperty.Name, "Base", StringComparison.Ordinal)
                || string.Equals(targetProperty.Name, "EnableParent", StringComparison.Ordinal)
                || string.Equals(targetProperty.Name, "LightData", StringComparison.Ordinal))
            {
                if (TryAssignCompositeProperty(targetRecord, targetProperty, winningValue, settings))
                {
                    changedAny = true;
                }

                continue;
            }

            if (!TryCloneForAssignment(winningValue, out var assignmentValue))
            {
                if (string.Equals(targetProperty.Name, "Emittance", StringComparison.Ordinal)
                    || string.Equals(targetProperty.Name, "Radius", StringComparison.Ordinal))
                {
                    if (TryAssignCompositeProperty(targetRecord, targetProperty, winningValue, settings))
                    {
                        changedAny = true;
                    }

                    continue;
                }

                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: skipped '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)} (value cannot be safely cloned).");
                }

                continue;
            }

            if (assignmentValue is not null && !targetProperty.PropertyType.IsInstanceOfType(assignmentValue))
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: skipped '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)} (type mismatch).");
                }

                continue;
            }

            try
            {
                targetProperty.SetValue(targetRecord, assignmentValue);
                changedAny = true;
            }
            catch (Exception ex)
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: failed setting '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)}: {ex.GetType().Name}");
                }
            }
        }

        return changedAny;
    }

    private static bool TryAssignCompositeProperty(object targetRecord, PropertyInfo targetProperty, object? winningValue, Settings settings)
    {
        if (winningValue is null)
        {
            try
            {
                targetProperty.SetValue(targetRecord, null);
                return true;
            }
            catch
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: skipped '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)} (null not assignable).");
                }

                return false;
            }
        }

        if (targetProperty.PropertyType.IsInstanceOfType(winningValue))
        {
            var assignValue = winningValue;
            if (TryCloneForAssignment(winningValue, out var clonedValue))
            {
                assignValue = clonedValue;
            }

            try
            {
                targetProperty.SetValue(targetRecord, assignValue);
                return true;
            }
            catch (Exception ex)
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: failed direct assign for '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)}: {ex.GetType().Name}");
                }
            }
        }

        if (TryCreateCompositeForTarget(winningValue, targetProperty.PropertyType, out var convertedValue))
        {
            try
            {
                targetProperty.SetValue(targetRecord, convertedValue);
                return true;
            }
            catch (Exception ex)
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: failed setting '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)}: {ex.GetType().Name}");
                }
            }
        }

        if (settings.Debug)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: skipped '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)} (could not map sub-values).");
        }

        return false;
    }

    private static bool TryCreateCompositeForTarget(object sourceValue, Type targetType, out object? targetValue)
    {
        targetValue = null;

        object? created;
        try
        {
            created = System.Activator.CreateInstance(targetType);
        }
        catch
        {
            return false;
        }

        if (created is null)
        {
            return false;
        }

        var wroteAny = false;
        var targetMembers = targetType.GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(x => x.CanWrite && x.GetIndexParameters().Length == 0);

        foreach (var targetMember in targetMembers)
        {
            var sourceMember = sourceValue.GetType().GetProperty(targetMember.Name, BindingFlags.Public | BindingFlags.Instance);
            if (sourceMember is null || !sourceMember.CanRead || sourceMember.GetIndexParameters().Length > 0)
            {
                continue;
            }

            var sourceMemberValue = sourceMember.GetValue(sourceValue);
            if (!TryConvertMemberValue(sourceMemberValue, targetMember.PropertyType, out var convertedMemberValue))
            {
                continue;
            }

            try
            {
                targetMember.SetValue(created, convertedMemberValue);
                wroteAny = true;
            }
            catch
            {
            }
        }

        if (!wroteAny)
        {
            return false;
        }

        targetValue = created;
        return true;
    }

    private static bool TryConvertMemberValue(object? sourceValue, Type targetType, out object? convertedValue)
    {
        convertedValue = null;

        if (sourceValue is null)
        {
            return true;
        }

        if (targetType.IsInstanceOfType(sourceValue))
        {
            if (TryCloneForAssignment(sourceValue, out convertedValue))
            {
                return true;
            }
        }

        if (TryConvertByFormKey(sourceValue, targetType, out convertedValue))
        {
            return true;
        }

        if (TryConvertNumeric(sourceValue, targetType, out convertedValue))
        {
            return true;
        }

        return false;
    }

    private static bool TryConvertByFormKey(object sourceValue, Type targetType, out object? convertedValue)
    {
        convertedValue = null;
        if (!TryGetFormKey(sourceValue, out var sourceFormKey))
        {
            return false;
        }

        object? targetObject;
        if (TryCreateInterfaceFormLinkTarget(targetType, sourceFormKey, out targetObject))
        {
            convertedValue = targetObject;
            return true;
        }

        try
        {
            targetObject = System.Activator.CreateInstance(targetType);
        }
        catch
        {
            return false;
        }

        if (targetObject is null)
        {
            return false;
        }

        var targetFormKeyProperty = targetType.GetProperty("FormKey", BindingFlags.Public | BindingFlags.Instance);
        if (targetFormKeyProperty is null || !targetFormKeyProperty.CanWrite || targetFormKeyProperty.PropertyType != typeof(FormKey))
        {
            return false;
        }

        targetFormKeyProperty.SetValue(targetObject, sourceFormKey);

        var sourceIsNullProperty = sourceValue.GetType().GetProperty("IsNull", BindingFlags.Public | BindingFlags.Instance);
        var targetIsNullProperty = targetType.GetProperty("IsNull", BindingFlags.Public | BindingFlags.Instance);
        if (targetIsNullProperty is not null
            && targetIsNullProperty.CanWrite
            && targetIsNullProperty.PropertyType == typeof(bool))
        {
            var isNull = sourceFormKey.IsNull;
            if (sourceIsNullProperty is not null
                && sourceIsNullProperty.CanRead
                && sourceIsNullProperty.PropertyType == typeof(bool)
                && sourceIsNullProperty.GetValue(sourceValue) is bool sourceIsNull)
            {
                isNull = sourceIsNull;
            }

            targetIsNullProperty.SetValue(targetObject, isNull);
        }

        convertedValue = targetObject;
        return true;
    }

    private static bool TryCreateInterfaceFormLinkTarget(Type targetType, FormKey sourceFormKey, out object? targetObject)
    {
        targetObject = null;
        if (!targetType.IsInterface || !targetType.IsGenericType)
        {
            return false;
        }

        var genericDefinition = targetType.GetGenericTypeDefinition();
        var genericArgument = targetType.GetGenericArguments()[0];
        Type? concreteType = null;
        object? ctorArg = null;
        Type? ctorArgType = null;

        if (genericDefinition == typeof(IFormLink<>) || genericDefinition == typeof(IFormLinkGetter<>))
        {
            concreteType = typeof(FormLink<>).MakeGenericType(genericArgument);
            ctorArg = sourceFormKey;
            ctorArgType = typeof(FormKey);
        }
        else if (genericDefinition == typeof(IFormLinkNullable<>) || genericDefinition == typeof(IFormLinkNullableGetter<>))
        {
            concreteType = typeof(FormLinkNullable<>).MakeGenericType(genericArgument);
            ctorArg = sourceFormKey.IsNull ? (FormKey?)null : sourceFormKey;
            ctorArgType = typeof(FormKey?);
        }

        if (concreteType is null)
        {
            return false;
        }

        var constructor = concreteType.GetConstructor([ctorArgType!]);
        if (constructor is not null)
        {
            targetObject = constructor.Invoke([ctorArg]);
            return true;
        }

        try
        {
            targetObject = System.Activator.CreateInstance(concreteType);
        }
        catch
        {
            return false;
        }

        if (targetObject is null)
        {
            return false;
        }

        var formKeyProperty = concreteType.GetProperty("FormKey", BindingFlags.Public | BindingFlags.Instance);
        if (formKeyProperty is null || !formKeyProperty.CanWrite || formKeyProperty.PropertyType != typeof(FormKey))
        {
            return false;
        }

        formKeyProperty.SetValue(targetObject, sourceFormKey);
        return true;
    }

    private static bool TryConvertNumeric(object sourceValue, Type targetType, out object? convertedValue)
    {
        convertedValue = null;
        var underlyingTargetType = Nullable.GetUnderlyingType(targetType) ?? targetType;
        if (!IsNumericType(underlyingTargetType))
        {
            return false;
        }

        try
        {
            convertedValue = Convert.ChangeType(sourceValue, underlyingTargetType, CultureInfo.InvariantCulture);
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static bool IsNumericType(Type type)
    {
        return type == typeof(byte)
            || type == typeof(sbyte)
            || type == typeof(short)
            || type == typeof(ushort)
            || type == typeof(int)
            || type == typeof(uint)
            || type == typeof(long)
            || type == typeof(ulong)
            || type == typeof(float)
            || type == typeof(double)
            || type == typeof(decimal);
    }

    private static bool TryAssignPlacement(object targetRecord, PropertyInfo targetProperty, object? winningValue, Settings settings)
    {
        if (winningValue is null)
        {
            try
            {
                targetProperty.SetValue(targetRecord, null);
                return true;
            }
            catch
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: skipped 'Placement' on {GetRecordIdentity(targetRecord)} (null placement not assignable).");
                }

                return false;
            }
        }

        if (TryCloneForAssignment(winningValue, out var clonedPlacement)
            && clonedPlacement is not null
            && targetProperty.PropertyType.IsInstanceOfType(clonedPlacement))
        {
            try
            {
                targetProperty.SetValue(targetRecord, clonedPlacement);
                return true;
            }
            catch (Exception ex)
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: failed setting cloned Placement on {GetRecordIdentity(targetRecord)}: {ex.GetType().Name}");
                }
            }
        }

        if (!TryCreatePlacementForTarget(winningValue, targetProperty.PropertyType, out var convertedPlacement))
        {
            if (settings.Debug)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: skipped 'Placement' on {GetRecordIdentity(targetRecord)} (could not convert placement type).");
            }

            return false;
        }

        try
        {
            targetProperty.SetValue(targetRecord, convertedPlacement);
            return true;
        }
        catch (Exception ex)
        {
            if (settings.Debug)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: failed setting converted Placement on {GetRecordIdentity(targetRecord)}: {ex.GetType().Name}");
            }

            return false;
        }
    }

    private static bool TryCreatePlacementForTarget(object sourcePlacement, Type targetPlacementType, out object? targetPlacement)
    {
        targetPlacement = null;

        if (!TryReadVector3(sourcePlacement, "Position", out var sourcePosition)
            || !TryReadVector3(sourcePlacement, "Rotation", out var sourceRotation))
        {
            return false;
        }

        object? created;
        try
        {
            created = System.Activator.CreateInstance(targetPlacementType);
        }
        catch
        {
            return false;
        }

        if (created is null)
        {
            return false;
        }

        if (!TryWriteVector3(created, "Position", sourcePosition) || !TryWriteVector3(created, "Rotation", sourceRotation))
        {
            return false;
        }

        targetPlacement = created;
        return true;
    }

    private static bool TryReadVector3(object owner, string propertyName, out (double X, double Y, double Z) value)
    {
        value = default;
        var property = owner.GetType().GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);
        if (property is null || !property.CanRead)
        {
            return false;
        }

        var vector = property.GetValue(owner);
        if (vector is null)
        {
            return false;
        }

        if (!TryReadNumericMember(vector, "X", out var x)
            || !TryReadNumericMember(vector, "Y", out var y)
            || !TryReadNumericMember(vector, "Z", out var z))
        {
            return false;
        }

        value = (x, y, z);
        return true;
    }

    private static bool TryWriteVector3(object owner, string propertyName, (double X, double Y, double Z) value)
    {
        var property = owner.GetType().GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);
        if (property is null || !property.CanWrite)
        {
            return false;
        }

        object? vector;
        try
        {
            vector = System.Activator.CreateInstance(property.PropertyType);
        }
        catch
        {
            return false;
        }

        if (vector is null)
        {
            return false;
        }

        if (!TryWriteNumericMember(vector, "X", value.X)
            || !TryWriteNumericMember(vector, "Y", value.Y)
            || !TryWriteNumericMember(vector, "Z", value.Z))
        {
            return false;
        }

        property.SetValue(owner, vector);
        return true;
    }

    private static bool TryReadNumericMember(object owner, string memberName, out double value)
    {
        value = default;
        var property = owner.GetType().GetProperty(memberName, BindingFlags.Public | BindingFlags.Instance);
        if (property is null || !property.CanRead)
        {
            return false;
        }

        var raw = property.GetValue(owner);
        if (raw is null)
        {
            return false;
        }

        try
        {
            value = Convert.ToDouble(raw, CultureInfo.InvariantCulture);
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static bool TryWriteNumericMember(object owner, string memberName, double value)
    {
        var property = owner.GetType().GetProperty(memberName, BindingFlags.Public | BindingFlags.Instance);
        if (property is null || !property.CanWrite)
        {
            return false;
        }

        var targetType = Nullable.GetUnderlyingType(property.PropertyType) ?? property.PropertyType;

        object converted;
        try
        {
            converted = Convert.ChangeType(value, targetType, CultureInfo.InvariantCulture);
        }
        catch
        {
            return false;
        }

        property.SetValue(owner, converted);
        return true;
    }

    private static bool TryCloneForAssignment(object? value, out object? clonedValue)
    {
        if (value is null)
        {
            clonedValue = null;
            return true;
        }

        var valueType = value.GetType();
        if (valueType.IsValueType || value is string)
        {
            clonedValue = value;
            return true;
        }

        var deepCopyMethod = valueType.GetMethod("DeepCopy", Type.EmptyTypes);
        if (deepCopyMethod is not null)
        {
            clonedValue = deepCopyMethod.Invoke(value, null);
            return true;
        }

        clonedValue = null;
        return false;
    }

    private static string GetRecordIdentity(object record)
    {
        if (TryGetFormKey(record, out var formKey))
        {
            return formKey.ToString();
        }

        return record.GetType().Name;
    }

    private static bool ValuesEqual(object? left, object? right)
    {
        if (ReferenceEquals(left, right))
        {
            return true;
        }

        if (left is null || right is null)
        {
            return false;
        }

        if (TryGetIsNull(left, out var leftIsNull) && TryGetIsNull(right, out var rightIsNull) && leftIsNull && rightIsNull)
        {
            return true;
        }

        if (TryGetFormKey(left, out var leftFormKey) && TryGetFormKey(right, out var rightFormKey))
        {
            return leftFormKey == rightFormKey;
        }

        if (left is IEnumerable leftEnumerable && right is IEnumerable rightEnumerable && left is not string && right is not string)
        {
            var leftList = leftEnumerable.Cast<object?>().ToList();
            var rightList = rightEnumerable.Cast<object?>().ToList();
            if (leftList.Count != rightList.Count)
            {
                return false;
            }

            for (var i = 0; i < leftList.Count; i++)
            {
                if (!ValuesEqual(leftList[i], rightList[i]))
                {
                    return false;
                }
            }

            return true;
        }

        return left.Equals(right);
    }

    private static bool TryGetFormKey(object value, out FormKey formKey)
    {
        formKey = default;
        var property = value.GetType().GetProperty("FormKey");
        if (property is null || property.PropertyType != typeof(FormKey))
        {
            return false;
        }

        var raw = property.GetValue(value);
        if (raw is not FormKey key)
        {
            return false;
        }

        formKey = key;
        return true;
    }

    private static bool TryGetIsNull(object value, out bool isNull)
    {
        isNull = false;
        var property = value.GetType().GetProperty("IsNull");
        if (property is null || property.PropertyType != typeof(bool))
        {
            return false;
        }

        var raw = property.GetValue(value);
        if (raw is not bool valueIsNull)
        {
            return false;
        }

        isNull = valueIsNull;
        return true;
    }
}
