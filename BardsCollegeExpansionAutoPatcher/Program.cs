using System.Collections;
using System.Globalization;
using System.Reflection;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

namespace BardsCollegeExpansionAutoPatcher;

public static class Program
{
    private static readonly ModKey BceModKey = ModKey.FromNameAndExtension("kinggathcreations_bard.esm");
    private static readonly FormKey VanillaBardsCollegeCell = new(ModKey.FromNameAndExtension("Skyrim.esm"), 0x016A0C);
    private static readonly FormKey BceBardsCollegeCell = new(BceModKey, 0x01F0F8);
    private static readonly HashSet<ModKey> VanillaMasterModKeys =
    [
        ModKey.FromNameAndExtension("Skyrim.esm"),
        ModKey.FromNameAndExtension("Update.esm"),
        ModKey.FromNameAndExtension("Dawnguard.esm"),
        ModKey.FromNameAndExtension("HearthFires.esm"),
        ModKey.FromNameAndExtension("Dragonborn.esm")
    ];
    private static readonly HashSet<string> SyncedPlacedPropertyNames =
    [
        "Base",
        "Placement",
        "Scale",
        "Emittance",
        "LightData",
        "Radius",
        "EnableParent",
        "MajorFlags",
        "Flags",
        "Ownership",
        "LockData",
        "LinkedReferences",
        "ActivateParents",
        "Primitive",
        "LocationRefType",
        "TeleportDestination"
    ];
    private static readonly HashSet<string> ExcludedCellPropertyNames =
    [
        "FormKey",
        "EditorID",
        "Persistent",
        "Temporary"
    ];

    private static Lazy<Settings> _settings = null!;

    public static async Task<int> Main(string[] args)
    {
        var pipeline = SynthesisPipeline.Instance;
        pipeline.SetAutogeneratedSettings<Settings>("Settings", "settings.json", out _settings);

        return await pipeline
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
            .SetTypicalOpen(GameRelease.SkyrimSE, "BardsCollegeExpansionPatch.esp")
            .Run(args);
    }

    public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        var settings = _settings.Value;

        var bceModPresent = state.LoadOrder.ContainsKey(BceModKey);
        if (!bceModPresent)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Required mod missing: {BceModKey.FileName}");
            return;
        }

        if (!state.PatchMod.ModHeader.MasterReferences.Any(master => master.Master == BceModKey))
        {
            state.PatchMod.ModHeader.MasterReferences.Add(new MasterReference { Master = BceModKey });
        }

        var csvPath = Path.Combine(AppContext.BaseDirectory, "BardsCollegeMatchingRefs.csv");
        if (!File.Exists(csvPath))
        {
            throw new FileNotFoundException($"Could not locate bundled CSV file at '{csvPath}'.", csvPath);
        }

        var refMapping = RefMapping.Load(csvPath);

        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] BCE detected: {BceModKey.FileName}");
        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Loaded {refMapping.Cell1ToCell2.Count} reference mappings.");

        if (settings.Debug)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Vanilla cell: {VanillaBardsCollegeCell}");
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] BCE cell: {BceBardsCollegeCell}");
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Blacklist size: {settings.BlacklistedPlugins.Count}");
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Cell1 CSV prefixes: {string.Join(", ", refMapping.Cell1LoadOrderPrefixes)}");
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Cell2 CSV prefixes: {string.Join(", ", refMapping.Cell2LoadOrderPrefixes)}");
        }

        if (refMapping.Cell1LoadOrderPrefixes.Any(prefix => !string.Equals(prefix, "00", StringComparison.Ordinal)))
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Warning: Cell1 mapping contains non-00 load-order prefixes.");
        }

        var intentionallyModifiedFormKeys = new HashSet<FormKey>();

        MoveNewReferencesToBceCell(state, settings, refMapping, intentionallyModifiedFormKeys);
        SyncMappedReferencesToBce(state, settings, refMapping, intentionallyModifiedFormKeys);
        SwapCellAndReferencePointers(state, settings, refMapping, intentionallyModifiedFormKeys);
        CleanupUnintentionalPatchRecords(state, intentionallyModifiedFormKeys, settings);
    }

    private static void MoveNewReferencesToBceCell(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        RefMapping refMapping,
        HashSet<FormKey> intentionallyModifiedFormKeys)
    {
        var winningCells = state.LoadOrder.PriorityOrder
            .Cell()
            .WinningContextOverrides(state.LinkCache)
            .ToDictionary(x => x.Record.FormKey, x => x);

        if (!winningCells.TryGetValue(VanillaBardsCollegeCell, out var vanillaCellContext))
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Could not resolve vanilla cell {VanillaBardsCollegeCell}.");
            return;
        }

        if (!winningCells.TryGetValue(BceBardsCollegeCell, out var bceCellContext))
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Could not resolve BCE cell {BceBardsCollegeCell}.");
            return;
        }

        var vanillaCellGetter = vanillaCellContext.Record;
        var bceCellGetter = bceCellContext.Record;

        var blacklistedMods = ParseBlacklist(settings.BlacklistedPlugins);
        var winningPersistentRefs = vanillaCellGetter.Persistent?.Select(x => x.FormKey).ToHashSet() ?? [];
        var winningTemporaryRefs = vanillaCellGetter.Temporary?.Select(x => x.FormKey).ToHashSet() ?? [];
        var allWinningRefs = (vanillaCellGetter.Persistent ?? [])
            .Concat(vanillaCellGetter.Temporary ?? [])
            .GroupBy(x => x.FormKey)
            .Select(x => x.First());

        var candidates = new List<IPlacedGetter>();
        foreach (var placed in allWinningRefs)
        {
            if (placed is not IPlacedObjectGetter && placed is not IPlacedNpcGetter && placed is not IAPlacedTrapGetter)
            {
                continue;
            }

            var sourceMod = placed.FormKey.ModKey;
            if (VanillaMasterModKeys.Contains(sourceMod))
            {
                continue;
            }

            if (sourceMod == BceModKey)
            {
                continue;
            }

            if (blacklistedMods.Contains(sourceMod))
            {
                continue;
            }

            if (refMapping.AllCell1Refs.Contains(placed.FormKey))
            {
                continue;
            }

            if (!IsTrulyNewReference(state, placed.FormKey))
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 2: skipped {placed.FormKey} (override of existing reference, not a net-new placed ref).");
                }

                continue;
            }

            candidates.Add(placed);
        }

        if (candidates.Count == 0)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 2: no new references to move.");
            return;
        }

        var vanillaCellOverride = vanillaCellContext.GetOrAddAsOverride(state.PatchMod);
        var bceCellOverride = bceCellContext.GetOrAddAsOverride(state.PatchMod);

        var movedCount = 0;
        foreach (var placed in candidates)
        {
            var shouldBePersistent = winningPersistentRefs.Contains(placed.FormKey) || !winningTemporaryRefs.Contains(placed.FormKey);
            var copied = ClonePlaced(placed);

            RemovePlacedByFormKey(vanillaCellOverride.Persistent, placed.FormKey);
            RemovePlacedByFormKey(vanillaCellOverride.Temporary, placed.FormKey);
            RemovePlacedByFormKey(bceCellOverride.Persistent, placed.FormKey);
            RemovePlacedByFormKey(bceCellOverride.Temporary, placed.FormKey);

            if (shouldBePersistent)
            {
                bceCellOverride.Persistent.Add(copied);
            }
            else
            {
                bceCellOverride.Temporary.Add(copied);
            }

            movedCount++;
            intentionallyModifiedFormKeys.Add(placed.FormKey);

            if (settings.Debug)
            {
                var destination = shouldBePersistent ? "Persistent" : "Temporary";
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Moved {placed.FormKey} -> BCE {destination}.");
            }
        }

        intentionallyModifiedFormKeys.Add(vanillaCellOverride.FormKey);
        intentionallyModifiedFormKeys.Add(bceCellOverride.FormKey);
        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 2: moved {movedCount} references to BCE cell.");
    }

    private static IPlaced ClonePlaced(IPlacedGetter placed)
    {
        return placed switch
        {
            IPlacedObjectGetter placedObject => placedObject.DeepCopy(),
            IPlacedNpcGetter placedNpc => placedNpc.DeepCopy(),
            IAPlacedTrapGetter placedTrap => placedTrap.DeepCopy(),
            _ => throw new InvalidOperationException($"Unsupported placed record type: {placed.GetType().Name}")
        };
    }

    private static HashSet<ModKey> ParseBlacklist(IEnumerable<string> rawBlacklist)
    {
        var result = new HashSet<ModKey>();

        foreach (var item in rawBlacklist)
        {
            var trimmed = item.Trim();
            if (string.IsNullOrWhiteSpace(trimmed))
            {
                continue;
            }

            if (ModKey.TryFromNameAndExtension(trimmed, out var modKey))
            {
                result.Add(modKey);
            }
        }

        return result;
    }

    private static bool RemovePlacedByFormKey(IList<IPlaced> list, FormKey formKey)
    {
        var removed = false;
        for (var i = list.Count - 1; i >= 0; i--)
        {
            if (list[i].FormKey != formKey)
            {
                continue;
            }

            list.RemoveAt(i);
            removed = true;
        }

        return removed;
    }

    private static bool IsTrulyNewReference(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        FormKey formKey)
    {
        var contexts = formKey
            .ToLink<IPlacedGetter>()
            .ResolveAllSimpleContexts<IPlacedGetter>(state.LinkCache)
            .Where(x => x.ModKey != state.PatchMod.ModKey)
            .ToList();

        if (contexts.Count == 0)
        {
            return true;
        }

        // If any vanilla context exists in the history, this is an override chain on an existing record.
        return !contexts.Any(x => VanillaMasterModKeys.Contains(x.ModKey));
    }

    private static void SyncMappedReferencesToBce(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        RefMapping refMapping,
        HashSet<FormKey> intentionallyModifiedFormKeys)
    {
        var blacklistedMods = ParseBlacklist(settings.BlacklistedPlugins);
        var loadOrderIndex = state.LoadOrder.ListedOrder
            .Select((listing, index) => (listing.ModKey, index))
            .ToDictionary(x => x.ModKey, x => x.index);

        var evaluated = 0;
        var changed = 0;

        foreach (var pair in refMapping.Cell1ToCell2)
        {
            evaluated++;

            var cell1Link = pair.Key.ToLink<IPlacedGetter>();
            var allCell1Contexts = cell1Link
                .ResolveAllSimpleContexts<IPlacedGetter>(state.LinkCache)
                .Select(x => (Typed: x, Untyped: (IModContext)x))
                .Where(x => x.Untyped.ModKey != state.PatchMod.ModKey)
                .ToList();

            if (allCell1Contexts.Count == 0)
            {
                continue;
            }

            var sourceContext = allCell1Contexts.FirstOrDefault(x => x.Untyped.ModKey == pair.Key.ModKey);
            if (sourceContext.Typed is null)
            {
                continue;
            }

            var winningContext = allCell1Contexts
                .Where(x => !blacklistedMods.Contains(x.Untyped.ModKey))
                .OrderBy(x => loadOrderIndex.TryGetValue(x.Untyped.ModKey, out var index) ? index : int.MinValue)
                .LastOrDefault();

            if (winningContext.Typed is null)
            {
                continue;
            }

            var winningModKey = winningContext.Untyped.ModKey;

            if (VanillaMasterModKeys.Contains(winningModKey) || winningModKey == BceModKey || blacklistedMods.Contains(winningModKey))
            {
                continue;
            }

            var originalRecord = sourceContext.Typed.Record;
            var winningRecord = winningContext.Typed.Record;

            var cell2Link = pair.Value.ToLink<IPlacedGetter>();
            if (!cell2Link.TryResolveContext<ISkyrimMod, ISkyrimModGetter, IPlaced, IPlacedGetter>(state.LinkCache, out var cell2Context))
            {
                continue;
            }

            var cell2Override = cell2Context.GetOrAddAsOverride(state.PatchMod);
            if (!HaveMatchingPlacedKind(winningRecord, cell2Override))
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: type mismatch for {pair.Key} -> {pair.Value}, skipping.");
                }

                continue;
            }

            if (!ApplyChangedProperties(originalRecord, winningRecord, cell2Override, settings))
            {
                continue;
            }

            changed++;
            intentionallyModifiedFormKeys.Add(cell2Override.FormKey);

            if (settings.Debug)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: synced {pair.Key} -> {pair.Value} from {winningModKey.FileName}.");
            }
        }

        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: evaluated {evaluated} mapped refs, synced {changed}.");

        SyncBardsCollegeCellChanges(state, settings, intentionallyModifiedFormKeys);
    }

    private static void SyncBardsCollegeCellChanges(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        HashSet<FormKey> intentionallyModifiedFormKeys)
    {
        var blacklistedMods = ParseBlacklist(settings.BlacklistedPlugins);
        var loadOrderIndex = state.LoadOrder.ListedOrder
            .Select((listing, index) => (listing.ModKey, index))
            .ToDictionary(x => x.ModKey, x => x.index);

        var vanillaCellLink = VanillaBardsCollegeCell.ToLink<ICellGetter>();
        var allVanillaCellContexts = vanillaCellLink
            .ResolveAllSimpleContexts<ICellGetter>(state.LinkCache)
            .Select(x => (Typed: x, Untyped: (IModContext)x))
            .Where(x => x.Untyped.ModKey != state.PatchMod.ModKey)
            .ToList();

        if (allVanillaCellContexts.Count == 0)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync: no contexts found for {VanillaBardsCollegeCell}.");
            return;
        }

        var sourceContext = allVanillaCellContexts.FirstOrDefault(x => x.Untyped.ModKey == VanillaBardsCollegeCell.ModKey);
        if (sourceContext.Typed is null)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync: source context missing for {VanillaBardsCollegeCell}.");
            return;
        }

        var winningContext = allVanillaCellContexts
            .Where(x => !blacklistedMods.Contains(x.Untyped.ModKey))
            .OrderBy(x => loadOrderIndex.TryGetValue(x.Untyped.ModKey, out var index) ? index : int.MinValue)
            .LastOrDefault();

        if (winningContext.Typed is null)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync: winning context missing for {VanillaBardsCollegeCell}.");
            return;
        }

        var winningModKey = winningContext.Untyped.ModKey;
        if (VanillaMasterModKeys.Contains(winningModKey) || winningModKey == BceModKey || blacklistedMods.Contains(winningModKey))
        {
            if (settings.Debug)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync: skipped (winning mod {winningModKey.FileName} is excluded).");
            }

            return;
        }

        var bceCellLink = BceBardsCollegeCell.ToLink<ICellGetter>();
        if (!bceCellLink.TryResolveContext<ISkyrimMod, ISkyrimModGetter, ICell, ICellGetter>(state.LinkCache, out var bceCellContext))
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync: could not resolve BCE cell {BceBardsCollegeCell}.");
            return;
        }

        var bceCellOverride = bceCellContext.GetOrAddAsOverride(state.PatchMod);
        var changedAny = ApplyChangedCellProperties(sourceContext.Typed.Record, winningContext.Typed.Record, bceCellOverride, settings);
        if (!changedAny)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync: no cell-level changes to mirror.");
            return;
        }

        intentionallyModifiedFormKeys.Add(bceCellOverride.FormKey);
        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync: mirrored cell-level changes from {winningModKey.FileName} to BCE cell.");
    }

    private static bool ApplyChangedCellProperties(
        object originalRecord,
        object winningRecord,
        object targetRecord,
        Settings settings)
    {
        var changedAny = false;
        var targetType = targetRecord.GetType();
        var originalType = originalRecord.GetType();
        var winningType = winningRecord.GetType();

        foreach (var targetProperty in targetType.GetProperties())
        {
            if (!targetProperty.CanRead || !targetProperty.CanWrite)
            {
                continue;
            }

            if (targetProperty.GetIndexParameters().Length > 0)
            {
                continue;
            }

            if (ExcludedCellPropertyNames.Contains(targetProperty.Name))
            {
                continue;
            }

            var originalProperty = originalType.GetProperty(targetProperty.Name);
            var winningProperty = winningType.GetProperty(targetProperty.Name);
            if (originalProperty is null || winningProperty is null || !originalProperty.CanRead || !winningProperty.CanRead)
            {
                continue;
            }

            var originalValue = originalProperty.GetValue(originalRecord);
            var winningValue = winningProperty.GetValue(winningRecord);
            if (ValuesEqual(originalValue, winningValue))
            {
                continue;
            }

            if (TryAssignCompositeProperty(targetRecord, targetProperty, winningValue, settings))
            {
                changedAny = true;
                continue;
            }

            if (settings.Debug)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3 cell sync: skipped '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)}.");
            }
        }

        return changedAny;
    }

    private static void SwapCellAndReferencePointers(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        Settings settings,
        RefMapping refMapping,
        HashSet<FormKey> intentionallyModifiedFormKeys)
    {
        var blacklistedMods = ParseBlacklist(settings.BlacklistedPlugins);
        var swapMap = BuildSwapMap(refMapping);

        var evaluatedRecords = 0;
        var qualifyingRecords = 0;
        var swappedRecords = 0;
        var swappedLinks = 0;

        foreach (var context in state.LoadOrder.ListedOrder.WinningContextOverrides<ISkyrimMod, ISkyrimModGetter, IMajorRecord, IMajorRecordGetter>(state.LinkCache))
        {
            evaluatedRecords++;
            var sourceModKey = context.ModKey;
            if (sourceModKey == state.PatchMod.ModKey
                || sourceModKey == BceModKey
                || VanillaMasterModKeys.Contains(sourceModKey)
                || blacklistedMods.Contains(sourceModKey))
            {
                continue;
            }

            if (context.Record is not IFormLinkContainerGetter recordWithLinks)
            {
                continue;
            }

            var matchedLinksInRecord = recordWithLinks
                .EnumerateFormLinks()
                .Count(link => swapMap.ContainsKey(link.FormKey));
            if (matchedLinksInRecord == 0)
            {
                continue;
            }

            qualifyingRecords++;

            var overrideRecord = context.GetOrAddAsOverride(state.PatchMod);
            if (overrideRecord is not IFormLinkContainer mutableRecord)
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 4: skipped {context.Record.FormKey} (not mutable FormLink container).");
                }

                continue;
            }

            mutableRecord.RemapLinks(swapMap);
            swappedRecords++;
            swappedLinks += matchedLinksInRecord;
            intentionallyModifiedFormKeys.Add(overrideRecord.FormKey);

            if (settings.Debug)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 4: remapped {matchedLinksInRecord} links in {overrideRecord.FormKey} from {sourceModKey.FileName}.");
            }
        }

        Console.WriteLine(
            $"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 4: evaluated {evaluatedRecords} winning records, "
            + $"found {qualifyingRecords} with BCE swaps, remapped {swappedLinks} links across {swappedRecords} records.");
    }

    private static Dictionary<FormKey, FormKey> BuildSwapMap(RefMapping refMapping)
    {
        var map = new Dictionary<FormKey, FormKey>(refMapping.Cell1ToCell2.Count + 1)
        {
            [VanillaBardsCollegeCell] = BceBardsCollegeCell
        };

        foreach (var pair in refMapping.Cell1ToCell2)
        {
            map[pair.Key] = pair.Value;
        }

        return map;
    }

    private static void CleanupUnintentionalPatchRecords(
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        HashSet<FormKey> intentionallyModifiedFormKeys,
        Settings settings)
    {
        var allPatchRecordKeys = state.PatchMod
            .EnumerateMajorRecords()
            .Select(record => record.FormKey)
            .ToHashSet();

        var totalBeforeCleanup = allPatchRecordKeys.Count;
        allPatchRecordKeys.ExceptWith(intentionallyModifiedFormKeys);
        var removedCount = allPatchRecordKeys.Count;
        if (removedCount > 0)
        {
            state.PatchMod.Remove(allPatchRecordKeys);
        }

        var keptCount = totalBeforeCleanup - removedCount;
        Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Cleanup: kept {keptCount} intentional records, removed {removedCount} non-intentional records.");
    }

    private static bool HaveMatchingPlacedKind(object left, object right)
    {
        return GetPlacedKind(left) == GetPlacedKind(right);
    }

    private static string GetPlacedKind(object value)
    {
        return value switch
        {
            IPlacedObjectGetter => "PlacedObject",
            IPlacedNpcGetter => "PlacedNpc",
            IAPlacedTrapGetter => "PlacedTrap",
            _ => "Unknown"
        };
    }

    private static bool ApplyChangedProperties(object originalRecord, object winningRecord, object targetRecord, Settings settings)
    {
        var changedAny = false;
        var targetType = targetRecord.GetType();
        var originalType = originalRecord.GetType();
        var winningType = winningRecord.GetType();

        foreach (var targetProperty in targetType.GetProperties())
        {
            if (!targetProperty.CanRead || !targetProperty.CanWrite)
            {
                continue;
            }

            if (targetProperty.GetIndexParameters().Length > 0)
            {
                continue;
            }

            if (targetProperty.Name is "FormKey" or "EditorID")
            {
                continue;
            }

            if (!SyncedPlacedPropertyNames.Contains(targetProperty.Name))
            {
                continue;
            }

            var originalProperty = originalType.GetProperty(targetProperty.Name);
            var winningProperty = winningType.GetProperty(targetProperty.Name);
            if (originalProperty is null || winningProperty is null || !originalProperty.CanRead || !winningProperty.CanRead)
            {
                continue;
            }

            var originalValue = originalProperty.GetValue(originalRecord);
            var winningValue = winningProperty.GetValue(winningRecord);

            if (ValuesEqual(originalValue, winningValue))
            {
                continue;
            }

            if (string.Equals(targetProperty.Name, "Placement", StringComparison.Ordinal))
            {
                if (TryAssignPlacement(targetRecord, targetProperty, winningValue, settings))
                {
                    changedAny = true;
                }

                continue;
            }

            if (string.Equals(targetProperty.Name, "Base", StringComparison.Ordinal)
                || string.Equals(targetProperty.Name, "EnableParent", StringComparison.Ordinal)
                || string.Equals(targetProperty.Name, "LightData", StringComparison.Ordinal))
            {
                if (TryAssignCompositeProperty(targetRecord, targetProperty, winningValue, settings))
                {
                    changedAny = true;
                }

                continue;
            }

            if (!TryCloneForAssignment(winningValue, out var assignmentValue))
            {
                if (string.Equals(targetProperty.Name, "Emittance", StringComparison.Ordinal)
                    || string.Equals(targetProperty.Name, "Radius", StringComparison.Ordinal))
                {
                    if (TryAssignCompositeProperty(targetRecord, targetProperty, winningValue, settings))
                    {
                        changedAny = true;
                    }

                    continue;
                }

                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: skipped '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)} (value cannot be safely cloned).");
                }

                continue;
            }

            if (assignmentValue is not null && !targetProperty.PropertyType.IsInstanceOfType(assignmentValue))
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: skipped '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)} (type mismatch).");
                }

                continue;
            }

            try
            {
                targetProperty.SetValue(targetRecord, assignmentValue);
                changedAny = true;
            }
            catch (Exception ex)
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: failed setting '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)}: {ex.GetType().Name}");
                }
            }
        }

        return changedAny;
    }

    private static bool TryAssignCompositeProperty(object targetRecord, PropertyInfo targetProperty, object? winningValue, Settings settings)
    {
        if (winningValue is null)
        {
            try
            {
                targetProperty.SetValue(targetRecord, null);
                return true;
            }
            catch
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: skipped '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)} (null not assignable).");
                }

                return false;
            }
        }

        if (targetProperty.PropertyType.IsInstanceOfType(winningValue))
        {
            var assignValue = winningValue;
            if (TryCloneForAssignment(winningValue, out var clonedValue))
            {
                assignValue = clonedValue;
            }

            try
            {
                targetProperty.SetValue(targetRecord, assignValue);
                return true;
            }
            catch (Exception ex)
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: failed direct assign for '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)}: {ex.GetType().Name}");
                }
            }
        }

        if (TryCreateCompositeForTarget(winningValue, targetProperty.PropertyType, out var convertedValue))
        {
            try
            {
                targetProperty.SetValue(targetRecord, convertedValue);
                return true;
            }
            catch (Exception ex)
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: failed setting '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)}: {ex.GetType().Name}");
                }
            }
        }

        if (settings.Debug)
        {
            Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: skipped '{targetProperty.Name}' on {GetRecordIdentity(targetRecord)} (could not map sub-values).");
        }

        return false;
    }

    private static bool TryCreateCompositeForTarget(object sourceValue, Type targetType, out object? targetValue)
    {
        targetValue = null;

        object? created;
        try
        {
            created = System.Activator.CreateInstance(targetType);
        }
        catch
        {
            return false;
        }

        if (created is null)
        {
            return false;
        }

        var wroteAny = false;
        var targetMembers = targetType.GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(x => x.CanWrite && x.GetIndexParameters().Length == 0);

        foreach (var targetMember in targetMembers)
        {
            var sourceMember = sourceValue.GetType().GetProperty(targetMember.Name, BindingFlags.Public | BindingFlags.Instance);
            if (sourceMember is null || !sourceMember.CanRead || sourceMember.GetIndexParameters().Length > 0)
            {
                continue;
            }

            var sourceMemberValue = sourceMember.GetValue(sourceValue);
            if (!TryConvertMemberValue(sourceMemberValue, targetMember.PropertyType, out var convertedMemberValue))
            {
                continue;
            }

            try
            {
                targetMember.SetValue(created, convertedMemberValue);
                wroteAny = true;
            }
            catch
            {
            }
        }

        if (!wroteAny)
        {
            return false;
        }

        targetValue = created;
        return true;
    }

    private static bool TryConvertMemberValue(object? sourceValue, Type targetType, out object? convertedValue)
    {
        convertedValue = null;

        if (sourceValue is null)
        {
            return true;
        }

        if (targetType.IsInstanceOfType(sourceValue))
        {
            if (TryCloneForAssignment(sourceValue, out convertedValue))
            {
                return true;
            }
        }

        if (TryConvertByFormKey(sourceValue, targetType, out convertedValue))
        {
            return true;
        }

        if (TryConvertNumeric(sourceValue, targetType, out convertedValue))
        {
            return true;
        }

        return false;
    }

    private static bool TryConvertByFormKey(object sourceValue, Type targetType, out object? convertedValue)
    {
        convertedValue = null;
        if (!TryGetFormKey(sourceValue, out var sourceFormKey))
        {
            return false;
        }

        object? targetObject;
        try
        {
            targetObject = System.Activator.CreateInstance(targetType);
        }
        catch
        {
            return false;
        }

        if (targetObject is null)
        {
            return false;
        }

        var targetFormKeyProperty = targetType.GetProperty("FormKey", BindingFlags.Public | BindingFlags.Instance);
        if (targetFormKeyProperty is null || !targetFormKeyProperty.CanWrite || targetFormKeyProperty.PropertyType != typeof(FormKey))
        {
            return false;
        }

        targetFormKeyProperty.SetValue(targetObject, sourceFormKey);

        var sourceIsNullProperty = sourceValue.GetType().GetProperty("IsNull", BindingFlags.Public | BindingFlags.Instance);
        var targetIsNullProperty = targetType.GetProperty("IsNull", BindingFlags.Public | BindingFlags.Instance);
        if (sourceIsNullProperty is not null
            && targetIsNullProperty is not null
            && sourceIsNullProperty.CanRead
            && targetIsNullProperty.CanWrite
            && sourceIsNullProperty.PropertyType == typeof(bool)
            && targetIsNullProperty.PropertyType == typeof(bool))
        {
            var sourceIsNull = sourceIsNullProperty.GetValue(sourceValue);
            if (sourceIsNull is bool b)
            {
                targetIsNullProperty.SetValue(targetObject, b);
            }
        }

        convertedValue = targetObject;
        return true;
    }

    private static bool TryConvertNumeric(object sourceValue, Type targetType, out object? convertedValue)
    {
        convertedValue = null;
        var underlyingTargetType = Nullable.GetUnderlyingType(targetType) ?? targetType;
        if (!IsNumericType(underlyingTargetType))
        {
            return false;
        }

        try
        {
            convertedValue = Convert.ChangeType(sourceValue, underlyingTargetType, CultureInfo.InvariantCulture);
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static bool IsNumericType(Type type)
    {
        return type == typeof(byte)
            || type == typeof(sbyte)
            || type == typeof(short)
            || type == typeof(ushort)
            || type == typeof(int)
            || type == typeof(uint)
            || type == typeof(long)
            || type == typeof(ulong)
            || type == typeof(float)
            || type == typeof(double)
            || type == typeof(decimal);
    }

    private static bool TryAssignPlacement(object targetRecord, PropertyInfo targetProperty, object? winningValue, Settings settings)
    {
        if (winningValue is null)
        {
            try
            {
                targetProperty.SetValue(targetRecord, null);
                return true;
            }
            catch
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: skipped 'Placement' on {GetRecordIdentity(targetRecord)} (null placement not assignable).");
                }

                return false;
            }
        }

        if (TryCloneForAssignment(winningValue, out var clonedPlacement)
            && clonedPlacement is not null
            && targetProperty.PropertyType.IsInstanceOfType(clonedPlacement))
        {
            try
            {
                targetProperty.SetValue(targetRecord, clonedPlacement);
                return true;
            }
            catch (Exception ex)
            {
                if (settings.Debug)
                {
                    Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: failed setting cloned Placement on {GetRecordIdentity(targetRecord)}: {ex.GetType().Name}");
                }
            }
        }

        if (!TryCreatePlacementForTarget(winningValue, targetProperty.PropertyType, out var convertedPlacement))
        {
            if (settings.Debug)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: skipped 'Placement' on {GetRecordIdentity(targetRecord)} (could not convert placement type).");
            }

            return false;
        }

        try
        {
            targetProperty.SetValue(targetRecord, convertedPlacement);
            return true;
        }
        catch (Exception ex)
        {
            if (settings.Debug)
            {
                Console.WriteLine($"[{nameof(BardsCollegeExpansionAutoPatcher)}] Phase 3: failed setting converted Placement on {GetRecordIdentity(targetRecord)}: {ex.GetType().Name}");
            }

            return false;
        }
    }

    private static bool TryCreatePlacementForTarget(object sourcePlacement, Type targetPlacementType, out object? targetPlacement)
    {
        targetPlacement = null;

        if (!TryReadVector3(sourcePlacement, "Position", out var sourcePosition)
            || !TryReadVector3(sourcePlacement, "Rotation", out var sourceRotation))
        {
            return false;
        }

        object? created;
        try
        {
            created = System.Activator.CreateInstance(targetPlacementType);
        }
        catch
        {
            return false;
        }

        if (created is null)
        {
            return false;
        }

        if (!TryWriteVector3(created, "Position", sourcePosition) || !TryWriteVector3(created, "Rotation", sourceRotation))
        {
            return false;
        }

        targetPlacement = created;
        return true;
    }

    private static bool TryReadVector3(object owner, string propertyName, out (double X, double Y, double Z) value)
    {
        value = default;
        var property = owner.GetType().GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);
        if (property is null || !property.CanRead)
        {
            return false;
        }

        var vector = property.GetValue(owner);
        if (vector is null)
        {
            return false;
        }

        if (!TryReadNumericMember(vector, "X", out var x)
            || !TryReadNumericMember(vector, "Y", out var y)
            || !TryReadNumericMember(vector, "Z", out var z))
        {
            return false;
        }

        value = (x, y, z);
        return true;
    }

    private static bool TryWriteVector3(object owner, string propertyName, (double X, double Y, double Z) value)
    {
        var property = owner.GetType().GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);
        if (property is null || !property.CanWrite)
        {
            return false;
        }

        object? vector;
        try
        {
            vector = System.Activator.CreateInstance(property.PropertyType);
        }
        catch
        {
            return false;
        }

        if (vector is null)
        {
            return false;
        }

        if (!TryWriteNumericMember(vector, "X", value.X)
            || !TryWriteNumericMember(vector, "Y", value.Y)
            || !TryWriteNumericMember(vector, "Z", value.Z))
        {
            return false;
        }

        property.SetValue(owner, vector);
        return true;
    }

    private static bool TryReadNumericMember(object owner, string memberName, out double value)
    {
        value = default;
        var property = owner.GetType().GetProperty(memberName, BindingFlags.Public | BindingFlags.Instance);
        if (property is null || !property.CanRead)
        {
            return false;
        }

        var raw = property.GetValue(owner);
        if (raw is null)
        {
            return false;
        }

        try
        {
            value = Convert.ToDouble(raw, CultureInfo.InvariantCulture);
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static bool TryWriteNumericMember(object owner, string memberName, double value)
    {
        var property = owner.GetType().GetProperty(memberName, BindingFlags.Public | BindingFlags.Instance);
        if (property is null || !property.CanWrite)
        {
            return false;
        }

        var targetType = Nullable.GetUnderlyingType(property.PropertyType) ?? property.PropertyType;

        object converted;
        try
        {
            converted = Convert.ChangeType(value, targetType, CultureInfo.InvariantCulture);
        }
        catch
        {
            return false;
        }

        property.SetValue(owner, converted);
        return true;
    }

    private static bool TryCloneForAssignment(object? value, out object? clonedValue)
    {
        if (value is null)
        {
            clonedValue = null;
            return true;
        }

        var valueType = value.GetType();
        if (valueType.IsValueType || value is string)
        {
            clonedValue = value;
            return true;
        }

        var deepCopyMethod = valueType.GetMethod("DeepCopy", Type.EmptyTypes);
        if (deepCopyMethod is not null)
        {
            clonedValue = deepCopyMethod.Invoke(value, null);
            return true;
        }

        clonedValue = null;
        return false;
    }

    private static string GetRecordIdentity(object record)
    {
        if (TryGetFormKey(record, out var formKey))
        {
            return formKey.ToString();
        }

        return record.GetType().Name;
    }

    private static bool ValuesEqual(object? left, object? right)
    {
        if (ReferenceEquals(left, right))
        {
            return true;
        }

        if (left is null || right is null)
        {
            return false;
        }

        if (TryGetIsNull(left, out var leftIsNull) && TryGetIsNull(right, out var rightIsNull) && leftIsNull && rightIsNull)
        {
            return true;
        }

        if (TryGetFormKey(left, out var leftFormKey) && TryGetFormKey(right, out var rightFormKey))
        {
            return leftFormKey == rightFormKey;
        }

        if (left is IEnumerable leftEnumerable && right is IEnumerable rightEnumerable && left is not string && right is not string)
        {
            var leftList = leftEnumerable.Cast<object?>().ToList();
            var rightList = rightEnumerable.Cast<object?>().ToList();
            if (leftList.Count != rightList.Count)
            {
                return false;
            }

            for (var i = 0; i < leftList.Count; i++)
            {
                if (!ValuesEqual(leftList[i], rightList[i]))
                {
                    return false;
                }
            }

            return true;
        }

        return left.Equals(right);
    }

    private static bool TryGetFormKey(object value, out FormKey formKey)
    {
        formKey = default;
        var property = value.GetType().GetProperty("FormKey");
        if (property is null || property.PropertyType != typeof(FormKey))
        {
            return false;
        }

        var raw = property.GetValue(value);
        if (raw is not FormKey key)
        {
            return false;
        }

        formKey = key;
        return true;
    }

    private static bool TryGetIsNull(object value, out bool isNull)
    {
        isNull = false;
        var property = value.GetType().GetProperty("IsNull");
        if (property is null || property.PropertyType != typeof(bool))
        {
            return false;
        }

        var raw = property.GetValue(value);
        if (raw is not bool valueIsNull)
        {
            return false;
        }

        isNull = valueIsNull;
        return true;
    }
}
